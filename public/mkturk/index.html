<!doctype html>

<head>
<meta name="mobile-web-app-capable" content="yes"> <!-- full screen https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="viewport" content="width=device-width, user-scalable=no"> <!-- do not allow window rescaling.  To avoid window rescaling in portrait mode, added with=device-width from http://stackoverflow.com/questions/22771523/ipad-w-retina-safari-reported-dimensions-in-landscape-make-no-sense. Also, removes 300-350ms tap delay (https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away) -->

<link rel="manifest" href="mkturkmanifest.json">
<link rel="icon" href="mkturklogo48.png">

<!-- Include Material Design Lite CDN hosted components -->
<!-- Gettign started @ https://getmdl.io/started/index.html -->
<!-- MDL color theme picker @ https://getmdl.io/customize/index.html -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-red.min.css">
<!-- <link rel="stylesheet" href="styles.css"> -->

<script>
var loadScriptAsync = function(uri){
  return new Promise((resolve, reject) => {
    var tag = document.createElement('script');
    tag.src = uri;
    tag.async = true;
    tag.onload = () => {
      resolve();
    };
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
});
} //loadScriptAsync

if (typeof(navigator.usb) == "object"){
	var usb_scriptLoaded = loadScriptAsync('mkturk_usb.js');
}
if (typeof(navigator.bluetooth) == "object"){
	var ble_scriptLoaded = loadScriptAsync('mkturk_bluetooth.js');
	var blescale_scriptLoaded = loadScriptAsync('mkturk_bluetoothscale.js');
}
</script>

<script src="mkturk_installsettings.js"></script>

<!-- Insert these scripts at the bottom of the HTML, but before you use any Firebase services -->
<!-- Firebase App (the core Firebase SDK) is always required and must be listed first -->
<script src="/__/firebase/7.3.0/firebase-app.js"></script>

<!-- Add Firebase products that you want to use -->
<script src="/__/firebase/7.3.0/firebase-auth.js"></script>
<script src="/__/firebase/7.3.0/firebase-firestore.js"></script>
<script src="/__/firebase/7.3.0/firebase-storage.js"></script>
<script src="/__/firebase/7.3.0/firebase-functions.js"></script>
<script src="/__/firebase/init.js"></script>

<!-- Math package -->
<script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/7.0.0/math.min.js type="text/javascript"></script> 

<script>
  //Initialize Cloud Firestore
  var db = firebase.firestore();

  //Initialize Cloud Storage
  var storage = firebase.storage();

 var functions = firebase.functions();
 let bqInsertEyeData = functions.httpsCallable("bqInsertEyeData")
 let bqInsertDisplayTimes = functions.httpsCallable("bqInsertDisplayTimes")
 let detectDevice = functions.httpsCallable("detectDevice")

 async function deviceDetect() {
  let navigator = window.navigator;

  // GPU INFO
  let canvas = document.createElement('canvas');
  let gl, debugInfo, vendor, renderer;
  try {
    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  } catch (e) {
    console.error('WebGL Context Error:', e);
    return;
  }
  if (gl) {
    debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
    renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
  }

  //TOUCH INFO
  // Chrome (desktop) used to lie about its support on this, but that has since been rectified: https://bugs.chromium.org/p/chromium/issues/detail?id=36415
  // Chrome also changed its behaviour since v70 and recommends the TouchEvent object for detection: https://www.chromestatus.com/feature/4764225348042752
  var touchscreen = 0
  if (('ontouchstart' in window) || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch) {
    touchscreen = 1;
  }
  
  //DEVICE INFO
  let deviceInfo = await detectDevice(navigator.userAgent);

	if (deviceInfo.data.device == null){
		deviceInfo.data.device = {"type": '', "brand": '', "model": ''}
	}//IF null

	if (deviceInfo.data.client == null){
		deviceInfo.data.client = {"name": '', "version": ''}
	}//IF null

	if (deviceInfo.data.os == null){
		deviceInfo.data.os = {"name": '', "version": ''}
	}//IF null

  deviceInfo.data.gpu = {};
  deviceInfo.data.gpu.vendor = vendor;
  deviceInfo.data.gpu.renderer = renderer;
  deviceInfo.data.touchscreen = touchscreen
  return deviceInfo;
}

</script>
</head>

<!-- Add ThreeJS -->
<script src="https://threejs.org/build/three.js"></script>
<script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

<!-- ************* (END) HEAD *************** -->


<!-- ************* BODY *************** -->
<body bgcolor=#7F7F7F>
<div id="canvasdiv" style="position:relative; width:100vw; height:100vh">
    <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--accent" id="googlesignin" style="z-index: 102; position: absolute; top: 0%; left: 92%">
      <i class="material-icons">person</i>
    </button>
    <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--accent" id="reloadpage" style="visibility:hidden; z-index: 102; position: absolute; top: 0%; left: 92%">
      <i class="material-icons">refresh</i>
    </button>

   <button class="mdl-button mdl-js-button mdl-button--raised" id="quickload" style="visibility:hidden; background-color:green; z-index: 102; font-size: 25px; position: absolute; top: 5%; left: 50%; height: 85px; width: 200px; border-radius: 20px">
     QUICK LOAD
   </button>

<div class="custom-select" id="subjectID_div" style="z-index: 102; font-size: 25px; position: absolute; top: 7.5%; left: 75%; height: 75px; width: 200px;">
	<label for="subjectID_select" >Select subject:</label>
	<select class="mdl-textfield__input" name="subjects" id="subjectID_select">
		<option value="-1">--</option>
	</select>
</div>

   <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="connectusb" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 12.5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
     CONNECT USB
   </button>

   <button class="mdl-button mdl-js-button mdl-button--raised" id="nousb" style="visibility:hidden; background-color:white; z-index: 102; font-size: 25px; position: absolute; top: 20%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
     NO USB
   </button>
 
  <button class="mdl-button mdl-js-button mdl-button--raised" id="pumpflush" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 12%; left: 80%; height: 45px; width: 150px; border-radius: 20px">
     Flush 1min
   </button>
 
  <button class="mdl-button mdl-js-button mdl-button--raised" id="pumptrigger" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 17%; left: 80%; height: 45px; width: 150px; border-radius: 11px">
     Calibrate 1mL milk
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="connectblescale" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 22%; left: 80%; height: 45px; width: 150px; border-radius: 20px">
     Connect BLE Scale
   </button>

	<p id="headsuptext" style="z-index:101; position: absolute; left: 1px; top: 1px; height: 40%; width: 50%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; word-break: break-all;"></p>

	<p id="headsuptextdevices" style="z-index:101; position: absolute; left: 50%; top: 1px; height: 40%; width: 40%; font-size: 16px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; word-break: break-all;">No devices connected</p>

	<p id="imageloadingtext" style="z-index:104; position: absolute; left: 1px; top: 1px; height: 5%; width: 100%; font-size: 16px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;  word-break: break-all;"></p>

  <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="doneEditingParams" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Done Editing Params
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="doneTestingTask" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 12.5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Done Practice
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="stressTest" style="visibility:hidden; background-color:white; z-index: 102; font-size: 25px; position: absolute; top: 20%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Stress Test
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="preemptRFID" style="visibility:hidden; background-color:red; z-index: 102; font-size: 25px; position: absolute; top: 20%; left: 5%; height: 75px; width: 200px; border-radius: 20px">
	Preempt RFID
   </button>

	<canvas id="canvasheadsup" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvasvisible" width="0" height="0" src="" style="z-index:1; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvasvisiblewebgl" width="0" height="0" src="" style="z-index:3; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvaseyetracker" width="0" height="0" src="" style="z-index:4; position: absolute; left: 0px; top: 0px;"> </canvas>
</div>

<script src="mkturk_globalvariables.js"></script>
<script src="mkturk_eventlisteners.js" type="text/javascript"></script>
<script src="mkturk_imagebuffer.js" type="text/javascript"></script>
<script src="mkturk_trialqueue_scene.js" type="text/javascript"></script>
<script src="mkturk_screenfunctions.js"></script>
<script src="mkturk_automator.js" type="text/javascript"></script>
<script src="mkturk_utils.js" type="text/javascript"></script>
<script src="mkturk_firebase.js" type="text/javascript"></script>
<script src="mkturk_firestore.js" type="text/javascript"></script>
<script src="mkturk_firebasestorage.js" type="text/javascript"></script>
<script src="mkturk_bigquery.js" type="text/javascript"></script>
<script src="mkturk_threejs.js" type="text/javascript"></script>
<script src="mkturk_eyetracker.js" type="text/javascript"></script>
<script>

//================== AUTHENTICATE GOOGLE ==================//
// [START authstatelistener]
var provider = new firebase.auth.GoogleAuthProvider();
provider.addScope('https://www.googleapis.com/auth/contacts.readonly');
firebase.auth().getRedirectResult().then(function(result) {
  if (result.user) {
    // User just signed in. you can get the result.credential.
    ENV.ResearcherDisplayName = result.user.displayName;
	ENV.ResearcherEmail = result.user.email;
	ENV.ResearcherID = result.user.uid

	console.log('Sign-In Redirect Result, USER ' + result.user.email + ' is signed in')
	updateHeadsUpDisplay()
  }
  else if (firebase.auth().currentUser) {
    // User already signed in.
	ENV.ResearcherDisplayName = firebase.auth().currentUser.displayName;
	ENV.ResearcherEmail = firebase.auth().currentUser.email;
	ENV.ResearcherID = firebase.auth().currentUser.uid

	console.log('Sign-In Redirect Result, USER ' + firebase.auth().currentUser.email + ' is signed in')
	updateHeadsUpDisplay()		
  }
  else {
    // No user signed in, update your UI, show the redirect sign-in screen.
	firebase.auth().signInWithRedirect(provider)
  }
});
//================== (end) AUTHENTICATE GOOGLE ==================//


// GET PARAMFILE NAME
var subjectlistobj = document.getElementById("subjectID_select");
for (var i=subjectlist.length-1; i>=0; i--){
	var opt = document.createElement('option');
	opt.value = i;
	opt.innerHTML = subjectlist[i];
	subjectlistobj.appendChild(opt);
}
subjectlistobj.addEventListener("change",subjectlist_listener,false);


// Check Availability of APIs
if (typeof(navigator.usb) == "object"){ ENV.WebUSBAvailable = 1 }
if (typeof(navigator.bluetooth) == "object"){ ENV.WebBluetoothAvailable = 1 }
if (typeof(navigator.getBattery) == "function"){ ENV.BatteryAPIAvailable = 1 }
if (typeof(OffscreenCanvas) == "function"){ ENV.OffscreenCanvasAvailable = 1 }

// Button callbacks for inline connection to arduino device
document.querySelector("button[id=googlesignin]").style.display = "block"
document.querySelector("button[id=googlesignin]").style.visibility = "visible"
document.querySelector("button[id=googlesignin]").addEventListener(
	'pointerup',firebaseRedirectSignIn,false)
document.querySelector("button[id=reloadpage]").addEventListener(
	'pointerup',function(){ window.location.reload(true) },false)

	//---- for Safari
	document.querySelector("button[id=googlesignin]").addEventListener(
		'click',firebaseRedirectSignIn,false)
	document.querySelector("button[id=reloadpage]").addEventListener(
		'click',function(){ window.location.reload(true) },false)
	//---- (END) for Safari


var textobj = document.getElementById("headsuptext")
textobj.addEventListener('pointerup',headsuptext_listener,false)

	//---- for Safari
	textobj.addEventListener('click',headsuptext_listener,false)
	//---- (END) for Safari


//============= Initialize Audio & Battery Objects ==================//
	// Prevent window scrolling and bounce back effect
	document.body.addEventListener('touchmove',function(event){
		event.preventDefault();
	}, {capture: false, passive:false});
	//Audio pulses for reward
	var audiocontext = new (window.AudioContext || window.webkitAudioContext)();
	var gainNode = audiocontext.createGain()
	gainNode.connect(audiocontext.destination)

	// Check availability of OffScreenCanvas API
	ENV.DevicePixelRatio = window.devicePixelRatio || 1;
	if (ENV.OffscreenCanvasAvailable){
		var visiblecontext = VISIBLECANVAS.getContext("bitmaprenderer");
	}
	else{
		var visiblecontext = VISIBLECANVAS.getContext("2d");
	}
	var backingStoreRatio = visiblecontext.webkitBackingStorePixelRatio ||
	                            visiblecontext.mozBackingStorePixelRatio ||
	                            visiblecontext.msBackingStorePixelRatio ||
	                            visiblecontext.oBackingStorePixelRatio ||
	                            visiblecontext.backingStorePixelRatio || 1;
	ENV.CanvasRatio = backingStoreRatio/ENV.DevicePixelRatio
	

	// Check Availability of Battery API
	if (ENV.BatteryAPIAvailable){
		//Monitor Battery - from: http://www.w3.org/TR/battery-status/
		navigator.getBattery().then(function(batteryobj){
			logEVENTS("Battery",[batteryobj.level, batteryobj.dischargingTime],"timeseries")

			batteryobj.addEventListener('levelchange',function(){
  		        logEVENTS("Battery",[batteryobj.level, batteryobj.dischargingTime],"timeseries")
			})//batteryobj.addEventListener
		}); //navigator.getBattery()
	}//IF battery API present
	else {
		//do nothing
	}//ELSE no battery api present
//============= (end) Initialize Audio & Battery Objects ==================//

function connectHardwareButtonPromise(){
  var resolveFunc
  var errFunc
  p = new Promise(function(resolve,reject){
    resolveFunc = resolve;
    errFunc = reject;
  }).then(function(resolveval){console.log('User clicked ' + resolveval)});

  function *waitforclickGenerator(){
    var buttonclicked =[-1];
    while (true){
      buttonclicked = yield buttonclicked;
      resolveFunc(buttonclicked);
    }
  }

  waitforClick = waitforclickGenerator(); // start async function
  waitforClick.next(); //move out of default state
  return p;
}

function skipHardwareDevice(event){
  event.preventDefault(); //prevents additional downstream call of click listener
  localStorage.setItem("ConnectUSB",0)
  waitforClick.next(1)
}


(async function(){
	document.querySelector ("button[id=quickload]").addEventListener(
		'pointerup',quickLoad_listener,false)

		//---- for Safari
		document.querySelector ("button[id=quickload]").addEventListener(
			'click',quickLoad_listener,false)

	if ( ENV.WebUSBAvailable ){
		await usb_scriptLoaded
		document.querySelector ("button[id=connectusb]").addEventListener(
			'pointerup',findUSBDevice,false)
		document.querySelector("button[id=nousb]").addEventListener(
			'pointerup',skipHardwareDevice,false)
		document.querySelector("button[id=preemptRFID]").addEventListener(
			'pointerup',preemptRFID_listener,false)	

			//---- for Safari
			document.querySelector ("button[id=connectusb]").addEventListener(
				'click',findUSBDevice,false)
			document.querySelector("button[id=nousb]").addEventListener(
				'click',skipHardwareDevice,false)
			document.querySelector("button[id=preemptRFID]").addEventListener(
				'click',preemptRFID_listener,false)	
			//---- (END) for Safari
	}

	if ( ENV.WebBluetoothAvailable ){
		await ble_scriptLoaded
		await blescale_scriptLoaded
		//Button callback for asynchronous connection to bluetooth scale
		document.querySelector("button[id=connectblescale]").addEventListener(
			'pointerup',blescaleconnect,false)	

			//---- for Safari
			document.querySelector("button[id=connectblescale]").addEventListener(
				'click',blescaleconnect,false)	
			//---- (END) for Safari
	}

	document.querySelector("button[id=doneEditingParams]").addEventListener(
		'pointerup',doneEditingParams_listener,false)
	document.querySelector("button[id=doneTestingTask]").addEventListener(
		'pointerup',doneTestingTask_listener,false)
	document.querySelector("button[id=stressTest]").addEventListener(
		'touchstart',stressTest_listener,false)

		//---- for Safari
		document.querySelector("button[id=doneEditingParams]").addEventListener(
			'click',doneEditingParams_listener,false)
		document.querySelector("button[id=doneTestingTask]").addEventListener(
			'click',doneTestingTask_listener,false)
		document.querySelector("button[id=stressTest]").addEventListener(
			'click',stressTest_listener,false)
		//---- (END) for Safari


	//====================== Retrieve device's screen properties ===========================//
	ENV.UserAgent = window.navigator.userAgent
	ENV.DeviceScreenWidth = window.screen.width
	ENV.DeviceScreenHeight = window.screen.height

	var deviceProperties = await deviceDetect()
	ENV.DeviceType = deviceProperties.data.device.type
	ENV.DeviceBrand = deviceProperties.data.device.brand
	ENV.DeviceName = deviceProperties.data.device.model
	ENV.DeviceGPU = deviceProperties.data.gpu.renderer
	ENV.DeviceBrowserName = deviceProperties.data.client.name
	ENV.DeviceBrowserVersion = deviceProperties.data.client.version
	ENV.DeviceOSName = deviceProperties.data.os.name
	ENV.DeviceOSVersion = deviceProperties.data.os.version
	ENV.DeviceTouchscreen = deviceProperties.data.touchscreen

	var screenSpecs = await queryDeviceonFirestore(ENV.DeviceName)
	//if device not identified by deviceAPI or no matching firestore devices record found for an identified device
	if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "desktop"){
		var screenSpecs = await queryDeviceonFirestore('32ul750') //default to desktop monitor
		console.log('Desktop detected, defaulting to LG 32ul750 monitor for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "tablet"){
		var screenSpecs = await queryDeviceonFirestore('pixel c') //default to pixel c
		console.log('Tablet detected, defaulting to pixel c tablet for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "mobile"){
		var screenSpecs = await queryDeviceonFirestore('pixel 4 xl') //default to pixel 4 xl
		console.log('Mobile detected, defaulting to pixel 4 xl phone for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && (ENV.DeviceType == "Not available" || ENV.DeviceType == '')){
		var screenSpecs = await queryDeviceonFirestore('pixel c') //default to pixel c
		console.log('Device type unidentified, defaulting to pixel c tablet for screen ppi')
	}

	ENV.ScreenSizeInches = screenSpecs.screenSizeInches
	ENV.ScreenPhysicalPixels = screenSpecs.screenPhysicalPixels //display pixels (<= physical screen pixels)
	ENV.ScreenRatio = screenSpecs.screenRatio //scaling from physical pixels to display pixels (retina display)
	ENV.PhysicalPPI = screenSpecs.ppi //physical device pixels per inch

	if (window.innerWidth < window.innerHeight){
		ENV.ScreenSizeInches = [ENV.ScreenSizeInches[1],ENV.ScreenSizeInches[0],ENV.ScreenSizeInches[2]]
		ENV.ScreenPhysicalPixels = [ENV.ScreenPhysicalPixels[1],ENV.ScreenPhysicalPixels[0]]
	} //IF PORTRAIT flip horizontal and vertical

	if (ENV.DevicePixelRatio != ENV.ScreenRatio){
		console.log("User is not running screen at native pixelratio which affects image scaling, will attempt to compensate")
	} //IF user not running screen at native scaling

	ENV.ViewportPixels[0] = ENV.ScreenPhysicalPixels[0]/ENV.DevicePixelRatio
	ENV.ViewportPixels[1] = ENV.ScreenPhysicalPixels[1]/ENV.DevicePixelRatio		

	ENV.ViewportPPI = ENV.ViewportPixels[0]/ENV.ScreenSizeInches[0] //viewport pixels per inch
	updateHeadsUpDisplay()
	//====================== (END) Retrieve device's screen properties ===========================//

	if ( ENV.WebUSBAvailable ){
		var event = {}
		event.type = "AutoConnect"
		await findUSBDevice(event)
	}

	//====================== Quickload Button Set-up ===========================//
	if ( localStorage.getItem("Agent") != null ){
		QuickLoad.agent = localStorage.getItem("Agent")
		QuickLoad.connectusb = localStorage.getItem("ConnectUSB")
		if (QuickLoad.connectusb == null){ QuickLoad.connectusb = 0}

		document.querySelector("button[id=quickload]").style.display = "block"
		document.querySelector("button[id=quickload]").style.visibility = "visible"

		if ( QuickLoad.connectusb == 0){
			document.querySelector("button[id=quickload]").innerHTML = QuickLoad.agent
		}
		else if ( QuickLoad.connectusb == 1){
			document.querySelector("button[id=quickload]").innerHTML = QuickLoad.agent + " <i>USB</i>"
		}
	} //IF agent stored locally, show quickload button
	else {
		document.querySelector("button[id=quickload]").style.display = "none"
	} //ELSE don't show button
	//====================== (END) Quickload Set-up ===========================//

	//================== AWAIT LOAD SUBJECT PARAMS ==================//
	document.querySelector("div[id=subjectID_div]").style.display = "block"
	document.querySelector("div[id=subjectID_div]").style.visibility = "visible"
	await subjectIDPromise()	
	document.querySelector("button[id=quickload]").style.display = "none"
	document.querySelector("div[id=subjectID_div]").style.display = "none"

	localStorage.setItem("Agent",ENV.Subject)	

	ENV.ParamFileName = PARAM_DIRPATH + ENV.Subject + "_params.txt";
	await loadParametersfromFirebase(ENV.ParamFileName)
	//================== (END) AWAIT LOAD SUBJECT PARAMS ==================//


	//====================== Connect USB ===========================//
	if ( ENV.WebUSBAvailable ){

		if (typeof(port.connected) == 'undefined' || port.connected == false){
			var event = {}
			event.type = "AutoConnect"
			await findUSBDevice(event)
		}

		if ( (typeof(port.connected) == 'undefined' || port.connected == false) &&
		     (QuickLoad.load == 0 || (QuickLoad.load == 1 && QuickLoad.connectusb == 1))){
			//=============== AWAIT CONNECT TO HARDWARE (via USB) ===============//
			port.connected = false
			document.querySelector("button[id=connectusb]").style.display = "block"
			document.querySelector("button[id=connectusb]").style.visibility = "visible"
			document.querySelector("button[id=nousb]").style.display = "block"
			document.querySelector("button[id=nousb]").style.visibility = "visible"

			await connectHardwareButtonPromise()
		} //IF !QuickLoad.load

		document.querySelector("button[id=connectusb]").style.display = "none"
		document.querySelector("button[id=nousb]").style.display = "none"
	}
	else {
		//skip usb device connection
		port={
		  statustext_connect: "",
		  statustext_sent: "",
		  statustext_received: "",
		  connected: false
		}
	}
	//====================== (END) Connect USB ===========================//

	if (ENV.WebBluetoothAvailable == 0){
		blescale = {
			connected: 0,
			statustext_connect: "",
			statustext_sent: "",
			statustext_received: "",
		}
		ble = {
			connected: 0,
		}
	}

	//================== AWAIT USER CAN EDIT SUBJECT PARAMS ==================//
	if (QuickLoad.load == 0){
		updateStatusText(JSON.stringify(TASK,null,' '));
		document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",true)
		document.querySelector("button[id=doneEditingParams]").style.display = "block"
		document.querySelector("button[id=doneEditingParams]").style.visibility = "visible"

		await editParamsPromise()
		document.querySelector("button[id=doneEditingParams]").style.display = "none"
		var textobj = document.getElementById("headsuptext")
		textobj.removeEventListener('touchend',headsuptext_listener)
		textobj.removeEventListener('mouseup',headsuptext_listener)
		document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",false)

		if (FLAGS.need2saveParameters == 1){
			var user_param_text = document.getElementById("headsuptext").innerHTML //get new params
			await saveParameterTexttoFirebase(user_param_text) //write new params
			await loadParametersfromFirebase(ENV.ParamFileName) //then read them
		} //IF 
	} //IF !QuickLoad.load
	//================== (END) AWAIT USER CAN EDIT SUBJECT PARAMS ==================//

  // //======================== CHECK IF FIRST NEED TO SAVE OUT IMAGE BAGS ==========================//
  // if (TASK.Agent != "SaveImages"){
	 //  var needsImageBag = []
	 //  var needsImageBagStr = ''
	 //  for (var i=0; i<=TASK.ImageBagsSample.length-1; i++){
		// scenebag = TASK.ImageBagsSample[i]
		// scenebag_dir = scenebag.slice(0,scenebag.lastIndexOf('/')+1)
		// // var filelist = await getFileListRecursiveFirebase(scenebag_dir)
		// var fileList = await storage.ref().child(scenebag_dir).listAll()
		// needsImageBag[i] = 1
		// for (var j=0; j<=fileList.prefixes.length-1; j++){
		// 	var containsSceneBagName = fileList.prefixes[j].name.indexOf(scenebag)
		// 	if (containsSceneBagName >= 0){
		// 		needsImageBag[i] = 0
		// 	}//IF found imagebag folder
		// }//FOR j folders
		// if (needsImageBag[i] == 1){
		// 	needsImageBagStr = needsImageBagStr + "<br>"
		// 					+ "Scene bag <b><i><font color=yellow>" + scenebag + "</font color></b></i> needs an image bag"
		// }
	 //  }//FOR i scenebag files
	 //  if (needsImageBagStr != ''){
		// var textobj = document.getElementById("headsuptext");
		// textobj.innerHTML = needsImageBagStr + "<br><br><b><font color=red> !!! PLEASE SAVE OUT IMAGES FIRST, THEN RELOAD TASK !!! <font color></b>"
		// return
	 //  }//IF needsImageBagStr
  // }//IF !SaveImages
  // //===================== (END) CHECK IF FIRST NEED TO SAVE OUT IMAGE BAGS =======================//

	//============= AWAIT READ SUBJECT PERFORMANCE HISTORY =============//
	// Read performance history
	var subject_behavior_save_directory = DATA_SAVEPATH + ENV.Subject + '/'
	if (TASK.Automator != 0){
		var history_file_paths = await getMostRecentBehavioralFilePathsFromFirebase(ndatafiles2read, ENV.Subject, subject_behavior_save_directory)
		trialhistory = await readTrialHistoryFromFirebase(history_file_paths);		
	}

	//===================== AWAIT INITIALIZE AUTOMATOR =================//
	// Initialize automator - change TASK to that specified by TASK.CurrentAutomatorStage. 
	var num_prebuffer_trials = 200
	if (TASK.Automator != 0){
		automator_data = await loadTextfromFirebase(TASK.AutomatorFilePath)
		automateTask(automator_data, trialhistory) 
		await saveParameterstoFirebase() 
		await loadParametersfromFirebase(ENV.ParamFileName);
	}//IF TASK.Automator != 0

	//============= AWAIT LOAD SOUNDS =============//
	soundpromises = sounds.serial.map(loadSoundfromFirebase); //create array of sound load Promises
	await Promise.all(soundpromises); //simultaneously evaluate array of sound load promises
	updateStatusText("")

    //============= AWAIT ESTIMATE SCREEN REFRESH RATE =========//
    var fps = await estimatefps()
    ENV.FrameRateDisplay = fps
    ENV.FrameRateMovie = fps/2

	//========= Start in TEST mode =======//
	document.querySelector("button[id=googlesignin]").style.display = "none" //if do style.visibility=hidden, element will still occupy space
	document.querySelector("button[id=reloadpage]").style.display = "block"
	document.querySelector("button[id=reloadpage]").style.visibility = "visible"

	document.querySelector("button[id=doneTestingTask]").style.display = "block"
	document.querySelector("button[id=doneTestingTask]").style.visibility = "visible"
	document.querySelector("button[id=stressTest]").style.display = "block"
	document.querySelector("button[id=stressTest]").style.visibility = "visible"
	if (TASK.Agent == "SaveImages"){
		document.querySelector("button[id=stressTest]").innerHTML = "Save Images"
    	TASK.SamplingStrategy = "sequential"
    	console.log("Automatically using sequential sampling since SAVE IMAGES was specified.")
	}//IF SaveImages

	FLAGS.need2loadParameters = 1
	FLAGS.need2loadScenes = 1
	CURRTRIAL.num = 0
	EVENTS.trialnum = 0
  FLAGS.savedata = 0 // test trials can be performed, but data won't be saved

// =========================================================================================================== // 
// ============ MAIN LOOP ==================================================================================== // 
// =========================================================================================================== // 
while(true){

	//============= AWAIT LOAD PARAMS =============//
	if (FLAGS.need2loadParameters == 1){
		FLAGS.need2loadParameters = await loadParametersfromFirebase(ENV.ParamFileName);

		if (typeof(TASK.TrackEye) != "undefined"){
		}
		else {
			TASK.TrackEye = 0;
		} //ELSE default to no eye tracking

		//load previous calibration if available
		if (TASK.TrackEye > 0 ){
			//Calibration
			ENV.Eye.calibration = 0;
			ENV.Eye.CalibXTransform = []
			ENV.Eye.CalibYTransform = []
			ENV.Eye.CalibType = 'default'
			ENV.Eye.NCalibPointsTrain = 0
			ENV.Eye.NCalibPointsTest = 0
			ENV.Eye.CalibTrainMSE = []
			ENV.Eye.CalibTestMSE = []

			await loadEyeCalibrationfromFirestore(ENV.Subject)
			if (ENV.Eye.CalibXTransform.length == 0){

				var xrange = 0.5
				var yrange = 0.5
				var xscale = ENV.ViewportPixels[0] / xrange;
				var yscale = ENV.ViewportPixels[1] / yrange;

				ENV.Eye.CalibXTransform = [ xscale, 0, -(0.5 - xrange/2)*xscale]
				ENV.Eye.CalibYTransform = [ 0, -yscale, ENV.ViewportPixels[1] + (0.5 - yrange/2)*yscale]

				// ENV.Eye.CalibXTransform = [ 1, 0, 0]
				// ENV.Eye.CalibYTransform = [ 0, 1, 0]

				saveEyeCalibrationtoFirestore(ENV.Eye.CalibXTransform,ENV.Eye.CalibYTransform,ENV.Eye.NCalibPoints,ENV.Eye.CalibType)
			}//default calibration
			if (TASK.CalibrateEye > 0){
 				//will calibrate using TASK.CalibrateEye number of trials for train & same number for test
 				ENV.Eye.calibration = 1
				ENV.Eye.NCalibPointsTrain = 0
				ENV.Eye.NCalibPointsTest = 0
				ENV.Eye.CalibTrainMSE = []
				ENV.Eye.CalibTestMSE = []
			}//IF calibrateeye
		}//IF trackeye

		//============= SET UP CANVAS =============//
		// Update canvas based on latest TASK state: 
		refreshCanvasSettings(TASK); 
		setupCanvasHeadsUp()
		setupImageLoadingText()
		windowWidth = document.body.clientWidth; //get true window dimensions at last possible moment
		windowHeight = document.body.clientHeight;
		setupCanvas(VISIBLECANVAS);

 		//Foreground canvas that displays eye position during practice screen
 		setupEyeTrackerCanvas()

		if (ENV.DevicePixelRatio !== 1){
			scaleCanvasforHiDPI(VISIBLECANVAS);
			scaleCanvasforHiDPI(EYETRACKERCANVAS);
		}
		if (ENV.OffscreenCanvasAvailable){
			OFFSCREENCANVAS = new OffscreenCanvas(VISIBLECANVAS.width, VISIBLECANVAS.height)
			OFFSCREENCANVAS.commitTo = function(dest){
				try {
					var bitmap = this.transferToImageBitmap()
					dest.transferFromImageBitmap(bitmap)
					str = {status: "succeeded"}
					return str
				}
				catch(error){
					console.log(error)
					str = {status: "failed"}
					return str				
				}
			}			
		}
		else
		{
			OFFSCREENCANVAS = VISIBLECANVAS
		}

		CANVAS.workspace = [
			0,
			0,
			VISIBLECANVAS.width,
			VISIBLECANVAS.height
		]

		TQS = undefined
		FLAGS.need2loadScenes = 1; 

		//Determine task type
		if (TASK.RewardStage == 0){
				ENV.Task = "FIXATION"
		}
		else if (TASK.RewardStage == 1){
            if (TASK.NRSVP > 0){
                ENV.Task = "RSVP"
            }
			else if (TASK.SameDifferent > 0 && TASK.ChoiceGridIndex.length == 2){
				//Same-Different (SD)
				ENV.Task = "SD"
			} //IF TASK.SameDifferent
			else if (TASK.ObjectGridIndex.length == TASK.ImageBagsSample.length){
				//Stimulus-Response (SR)
				ENV.Task = "SR"
			} //IF TASK.ObjectGridIndex
			else {
				//Match-to-Sample
				ENV.Task = "MTS"
			}
		} //if TASK.RewardStage

    ENV.FixationRadius = TASK.FixationSizeInches/2 * ENV.ViewportPPI
    ENV.SampleFixationRadius = TASK.SampleFixationSizeInches/2 * ENV.ViewportPPI
    ENV.ChoiceRadius = TASK.ChoiceSizeInches/2 * ENV.ViewportPPI

    // define image display grid
    funcreturn = defineImageGrid(TASK.NGridPoints, TASK.GridSpacingInches*ENV.ViewportPPI,TASK.GridXOffsetInches*ENV.ViewportPPI,TASK.GridYOffsetInches*ENV.ViewportPPI);
    xcanvascenter = funcreturn[0]
    ycanvascenter = funcreturn[1]
    ENV.XGridCenter = funcreturn[2]
    ENV.YGridCenter = funcreturn[3]

	FLAGS.purge = 1
	FLAGS.createnewfirestore = 1
    CURRTRIAL.reset()
	EVENTS.reset_trialseries()
    EVENTS.reset_timeseries()
	}//IF need2loadParameters

	if (FLAGS.purge == 1){
		purgeTrackingVariables()
		FLAGS.purge = 0; 
	} //if purge


	//======================== 3D SCENE SET-UP =======================//
	if (FLAGS.need2loadScenes){
		IMAGES = { Sample: [], Test: [] }
		IMAGEMETA = {}
		// STEPS FOR 3D SCENE SET-UP
		// ---- 0: load scene params from JSON
		// 0: expand trial params & get mesh paths
		// ---- 1: load meshes
		// ---- 2: init scene & camera
		// ---- 3: add all lights & objects
		// ---- 4: compile shaders
		// 5: select frame to render
		// 5: animate <--> render loop within trial

		//============ 0: LOAD SCENES from JSON ============//
		for (var f = 0; f <= TASK.ImageBagsSample.length-1; f++){
			IMAGES.Sample[f] = await loadTextfromFirebase(TASK.ImageBagsSample[f])
		}
		for (var f = 0; f <= TASK.ImageBagsTest.length-1; f++){
			IMAGES.Test[f] = await loadTextfromFirebase(TASK.ImageBagsTest[f])
		}
		//find longest scene param array in IMAGES (ie # of trials)
		for (var j = 0; j<=IMAGES.Sample.length-1; j++){
			IMAGES.Sample[j].nimages = getLongestArray(IMAGES.Sample[j])
			IMAGES.Test[j].nimages = getLongestArray(IMAGES.Test[j])

			//Determine if images will also be rendered
			IMAGES.Sample[j].nbackgroundimages = IMAGES.Sample[j].IMAGES.imageidx.length
			IMAGES.Test[j].nbackgroundimages = IMAGES.Test[j].IMAGES.imageidx.length

            FLAGS.movieper["Sample"][j] =[]
            FLAGS.movieper["Test"][j] = []
		}//FOR j scenes
		//============ (END) 0: LOAD SCENES from JSON ============//

		//============ 1: LOAD MESHES FOR SCENES ============//
		OBJECTS = {Sample: {}, Test: {}}
		for (var taskscreen in OBJECTS){
			var mesh_paths = []
			var mesh_inds = []
			for (var classlabel = 0; classlabel <= IMAGES[taskscreen].length-1; classlabel++){
				for (const obj in IMAGES[taskscreen][classlabel].OBJECTS){
					mesh_paths.push(IMAGES[taskscreen][classlabel].OBJECTS[obj].meshpath)
					mesh_inds.push([classlabel,obj])
				} //FOR obj objects in scene classlabel
			} //FOR classlabel scene
			var meshes = await loadMeshArrayfromFirebase(mesh_paths);

			for (var m=0; m<=meshes.length-1; m++){
				var meshlabel = mesh_inds[m][0]
        OBJECTS[taskscreen][meshlabel] = {"meshes": [] }
      }//FOR m meshes, initialize corresponding label to empty

      for (var m=0; m<=meshes.length-1; m++){
        var meshlabel = mesh_inds[m][0]
				var meshname = mesh_inds[m][1]
				OBJECTS[taskscreen][meshlabel].meshes[meshname] = meshes[m]
			}//FOR m meshes, store in corresponding label
		}//FOR taskscreen
		//============ (END) 1: LOAD MESHES FOR SCENES ============//


		//============ 2: INIT SCENE & CAMERA ============//
    setupCanvas(VISIBLECANVASWEBGL)
		await initThreeJS(IMAGES)
		//============ (END) 2: INIT SCENE & CAMERA ============//

		//============ 3: ADD ALL LIGHTS/OBJECTS TO SCENE ============//
	    CAMERAS = {Sample: {}, Test: {}}
	    LIGHTS = {Sample: {}, Test: {}}
		for (scenetype in scene){
			await addToScene(scenetype)
		}
		console.log('3js: added lights & objects')	
		//============ (END) 3: ADD ALL LIGHTS/OBJECTS TO SCENE ============//

		//============ 4: PRELOAD SHADERS (COMPILE) ============//
		for (scenetype in scene){
			renderer.compile(scene[scenetype],scene[scenetype].getObjectByName("cam0"))
		}
		console.log('3js: compiled scene')
		//============ (END) 4: PRELOAD SHADERS (COMPILE) ============//
		FLAGS.need2loadScenes = 0

		//Make a scene trial queue TQS (overrides TQ)
		TQS = new TrialQueueScene(TASK.SamplingStrategy)
		await TQS.build(num_prebuffer_trials)

		//Store some scene metadata
		var funcreturn = objectomeSceneNamesToLatentVars(TASK.ImageBagsSample,TQS.testbag_labels,IMAGES.Sample)
		var keys = Object.keys(funcreturn)
		for (var i=0; i<=keys.length-1; i++){
			IMAGEMETA["Sample" + keys[i]] = funcreturn[keys[i]]
		} //for i keys

		var funcreturn = objectomeSceneNamesToLatentVars(TASK.ImageBagsTest,TQS.testbag_labels,IMAGES.Test)
		var keys = Object.keys(funcreturn)
		for (var i=0; i<=keys.length-1; i++){
			IMAGEMETA["Test" + keys[i]] = funcreturn[keys[i]]
		} //for i keys
	} //IF load scenes

    if (typeof(TASK.BackgroundColor2D) == "undefined"){
        TASK.BackgroundColor2D = "#7F7F7F"
    }
    document.body.style.background = TASK.BackgroundColor2D;
	//========================(END) 3D SCENE SET-UP =======================//

	//============ SELECT SAMPLE & TEST IMAGES ============//
    if (typeof(TASK.NRSVP) == "undefined" || TASK.NRSVP <= 0){
      var imagesequencelength = 1;  
    }//IF !rsvp
    else{
      var imagesequencelength = TASK.NRSVP
    }//ELSE rsvp

    for (var i=0; i<=imagesequencelength-1; i++){
      var x = await TQS.get_next_trial()
      CURRTRIAL.sampleimage[i] = x[0]
      CURRTRIAL.sampleindex[i] = x[1]
	  
	  //Sample can have multiple sequential scenes (items are over time; eg, RSVP)
      CURRTRIAL.sampleindex_nonarray[i] = x[1][0]
      
      CURRTRIAL.sample_scenebag_label[i] = x[5]
      CURRTRIAL.sample_scenebag_index[i] = x[6]

      //Test can have multiple simultaneous scenes (items are over space; eg, MtS)
      if (i==0){
        CURRTRIAL.testimages[i] = x[2]
        CURRTRIAL.testindices[i] = x[3]
        CURRTRIAL.test_scenebag_labels[i] = x[7]
        CURRTRIAL.test_scenebag_indices[i] = x[8]

        CURRTRIAL.correctitem = x[4]
        samplereward = x[9]
      }//IF first image
    }//FOR i rsvp images

	logEVENTS("Sample",CURRTRIAL.sampleindex_nonarray,"trialseries")
	logEVENTS("Test",CURRTRIAL.testindices[0],"trialseries")
	logEVENTS("CorrectItem",CURRTRIAL.correctitem,"trialseries")
    //============(END) SELECT SAMPLE & TEST IMAGES ============//


    //============ SET UP SAMPLE & TEST SEQUENCE ============//
    //when & where to display
    CURRTRIAL.tsequence = [ 0 ]
    CURRTRIAL.sequencegridindex = [ [-1] ]

    //what to display
    CURRTRIAL.sequenceclip = [ -1 ] //movieclip# in RSVP
    CURRTRIAL.sequenceframe = [ -1 ] //frame# in movie
    CURRTRIAL.sequencetaskscreen = [ 'blank' ]
    CURRTRIAL.sequencelabel = [ [0] ] //image class
    CURRTRIAL.sequenceindex = [ [0] ] //image index

    //EXPAND SAMPLE (for rsvp & movies)
    //Start with blank for max(100,SampleOFF), then append SampleON+blank (eg, blank,Sample,blank,Sample,blank)
    for (var i=0; i<=CURRTRIAL.sample_scenebag_index.length-1; i++){
        var t0=CURRTRIAL.tsequence[CURRTRIAL.tsequence.length-1]
        var sampleon = chooseArrayElement(IMAGES["Sample"][CURRTRIAL.sample_scenebag_label[i][0]].durationMS, CURRTRIAL.sample_scenebag_index[i][0],0)

        //Timing: blankdurationpre, sampleon, framerate
        if (i==0){
            var blankdurationpre = Math.max(100,TASK.SampleOFF)
        }//if first blank, prepend at least 100ms
        else{
            var blankdurationpre = TASK.SampleOFF
        }

        //Create Movie Sequence
        [movie_sequence, movie_tsequence, movie_framenum] = 
        createMovieSeq("Sample",blankdurationpre, sampleon, TASK.SampleOFF, ENV.FrameRateMovie)
        movie_tsequence = movie_tsequence.map(function (a){return a + t0}) //shift clip's frames to absolute position in rsvp sequence

        CURRTRIAL.tsequence.push(...movie_tsequence)
        CURRTRIAL.sequencegridindex.push(...Array(movie_tsequence.length).fill([TASK.SampleGridIndex]))

        CURRTRIAL.sequenceclip.push(...Array(movie_tsequence.length).fill(i))
        CURRTRIAL.sequenceframe.push(...movie_framenum)
        CURRTRIAL.sequencetaskscreen.push(...movie_sequence)
        CURRTRIAL.sequencelabel.push(...Array(movie_tsequence.length).fill(CURRTRIAL.sample_scenebag_label[i]))
        CURRTRIAL.sequenceindex.push(...Array(movie_tsequence.length).fill(CURRTRIAL.sample_scenebag_index[i]))
    }//FOR i RSVP Sample

    //APPEND TEST OR CHOICE
    if (TASK.NRSVP <= 0){
        var t0 = CURRTRIAL.tsequence[CURRTRIAL.tsequence.length-1]
        var teston = chooseArrayElement(IMAGES["Test"][CURRTRIAL.test_scenebag_labels[0][0]].durationMS, CURRTRIAL.test_scenebag_indices[0][0],0)

if (typeof(teston) == "undefined"){
    console.log("Without this if, then print-to-console code, teston is undefined. Not clear why this strange behavior happens. Something to do with chooseArrayElement returning in time.")
}
        [movie_sequence, movie_tsequence, movie_framenum] = 
            createMovieSeq("Test",TASK.SampleOFF, teston, TASK.TestOFF, ENV.FrameRateMovie)
        movie_tsequence = movie_tsequence.map(function (a){return a + t0}) //shift frames to absolute position in sequence

        CURRTRIAL.tsequence.push(...movie_tsequence)
        CURRTRIAL.sequencegridindex.push(...Array(movie_tsequence.length).fill(TASK.TestGridIndex))

        CURRTRIAL.sequenceclip.push(...Array(movie_tsequence.length).fill(0))
        CURRTRIAL.sequenceframe.push(...movie_framenum)
        CURRTRIAL.sequencetaskscreen.push(...movie_sequence)
        CURRTRIAL.sequencelabel.push(...Array(movie_tsequence.length).fill(CURRTRIAL.test_scenebag_labels[0]))
        CURRTRIAL.sequenceindex.push(...Array(movie_tsequence.length).fill(CURRTRIAL.test_scenebag_indices[0]))

        //Append choice if needed
        if (TASK.SameDifferent > 0){
            var t0 = CURRTRIAL.tsequence[CURRTRIAL.tsequence.length-1]
            if (TASK.TestOFF > 0){
                var seq=["blank","choice"]
                var tseq=[ t0,t0+TASK.TestOFF ];
            }//ELSEIF TestOFF
            else if (TASK.TestOFF <= 0){
                var seq=["choice"]
                var tseq=[ t0 ];
            }//ELSEIF no TestOFF
            CURRTRIAL.tsequence.push(...tseq)
            CURRTRIAL.sequencegridindex.push(...Array(tseq.length).fill(TASK.ChoiceGridIndex))

            CURRTRIAL.sequenceclip.push(...Array(tseq.length).fill(0))
            CURRTRIAL.sequenceframe.push(...Array(tseq.length).fill(0))
            CURRTRIAL.sequencetaskscreen.push(...seq)
            CURRTRIAL.sequencelabel.push(...Array(tseq.length).fill([0]))
            CURRTRIAL.sequenceindex.push(...Array(tseq.length).fill([0]))
        }//IF Same-Different, show test & choice
    }//IF !RSVP, then show test/choice screen
//============(END) SET UP SAMPLE & TEST SEQUENCE ============//


	//================= RFID check =================//
	// If no matching read in the last TASK.CheckRFID seconds, wait for matching read
	// (kicks-them-off model where they can work as long as reading, but then get kicked off within TASK.CheckRFID seconds if they are the wrong agent or no reads)
	if (TASK.CheckRFID > 0 && ENV.AgentRFID != "XX" && FLAGS.savedata == 1){
		if (port.connected == false){
			console.log('NO USB DEVICE CONNECTED: cannot check RFID!!')
		}//IF !connected
		else if (port.connected == true){
			var nreads = EVENTS['timeseries']['RFIDTag'].length
	    	if (    EVENTS['timeseries']['RFIDTag'][nreads-1][2] == ENV.AgentRFID && 
                    (Date.now() - ENV.CurrentDate.valueOf()) - EVENTS['timeseries']['RFIDTag'][nreads-1][1] < TASK.CheckRFID
                ){
	    		// RFID checks out
	    	}
	    	else{ //wait for a recent rfid read before proceeding with next trial
				await rfid_promise(ENV.AgentRFID,TASK.CheckRFID)
	    	}
		}//ELSE connected
	}//IF CheckRFID
	//================= (end) RFID check =================//


// FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   //
// FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   //
// FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   FIXATION   //
//============ WHILE RUN FIXATION SCREEN ============//
	FLAGS.waitingforTouches = TASK.NFixations
	if (TASK.RewardStage == 0){
		FLAGS.punishOutsideTouch = 1		
	}
	CURRTRIAL.allfixationxyt = []
	while (FLAGS.waitingforTouches > 0){
		// Choose fixation grid index at random
		if (TASK.FixationGridIndex > 0){
            CURRTRIAL.fixationgridindex = TASK.FixationGridIndex;
		}
		else if (TASK.FixationGridIndex < 0){
            CURRTRIAL.fixationgridindex = Math.floor((ENV.XGridCenter.length)*Math.random()); 
		}
		logEVENTS("FixationGridIndex",CURRTRIAL.fixationgridindex,"trialseries")

        if (TASK.FixationUsesSample <= 0){
            // Render fixation screen 
            if (TASK.Species == "macaque" || TASK.Species == "human"){
                ENV.FixationColor = "white";
            }
            else if (TASK.Species == "marmoset"){
                ENV.FixationColor = "blue";
            }  
            frame.shown=[]; frame.frames=[]
            for (var q in CANVAS.sequencepre){ frame.shown[q]=0; frame.frames[q]=[q]}; 
            frame.current=0;                      
        }//IF !Sample, show fixation dot
		else if (TASK.FixationUsesSample > 0){
            //Update grid location of sample to current fixation grid index
            frame.shown = []; frame.frames=[]; frame.current=0
            for (var i=0; i<=CURRTRIAL.sequencegridindex.length-1; i++){
                for (var j=0; j<=CURRTRIAL.sequencegridindex[i].length-1; j++){
                    if (CURRTRIAL.sequencetaskscreen[i] == "Sample"){
                        CURRTRIAL.sequencegridindex[i][j] = CURRTRIAL.fixationgridindex
                        if (CURRTRIAL.sequenceclip[i] == 0 && j==0){
                            frame.shown.push(0)
                            frame.frames.push([i])
                        }//IF first clip, add frame
                    }//IF Sample
                }//FOR j display items
            }//FOR i frames

            boundingBoxesChoice3D = {'x':[],'y':[]} //determined on the fly during display
            //Get bounding box of first frame ahead of time
            f = frame.frames[0][0]
            var boundingBox3D = updateSingleFrame3D(CURRTRIAL.sequencetaskscreen[f],
                                                    CURRTRIAL.sequencelabel[f][0],
                                                    CURRTRIAL.sequenceindex[f][0],
                                                    CURRTRIAL.sequenceframe[f],
                                                    CURRTRIAL.sequencegridindex[f][0])//Update 3D scene prior to next frame draw
            boundingBoxesChoice3D.x[0] = boundingBox3D[CURRTRIAL.sequencelabel[f][0]][0].x
            boundingBoxesChoice3D.y[0] = boundingBox3D[CURRTRIAL.sequencelabel[f][0]][0].y            
        }//IF Sample, show first image/movie

		// Start timer for this fixation render trial. 
		CURRTRIAL.starttime=Date.now() - ENV.CurrentDate.valueOf();
		logEVENTS("StartTime",CURRTRIAL.starttime,"trialseries")

		//========= AWAIT SHOW FIXATION =========//
		// todo: move to appropriate location
		if (TASK.Species == 'marmoset'){
			playSound(0)
		}

        if (TASK.FixationUsesSample <= 0){
            displayTrial(CANVAS.tsequencepre,
                                [CURRTRIAL.fixationgridindex],[0],
                                CANVAS.sequencepre,[0],[0]) // dispTrial(time,grid,frame,screen,obj,idx)            
        }//IF !Sample, show fixation dot
        else if (TASK.FixationUsesSample > 0){
            displayTrial(CURRTRIAL.tsequence, CURRTRIAL.sequencegridindex, CURRTRIAL.sequenceframe,
                    CURRTRIAL.sequencetaskscreen, CURRTRIAL.sequencelabel, CURRTRIAL.sequenceindex)
        }//ELSE Sample, show image/movie

		audiocontext.suspend()

		//========= AWAIT HOLD FIXATION TOUCH =========//
		if (FLAGS.stressTest == 1){
			var touchhold_return = {type: "theld"}

			var x = boundingBoxesFixation.x[0][0] + Math.round(Math.random()*(boundingBoxesFixation.x[0][1] - boundingBoxesFixation.x[0][0]))
			var y = boundingBoxesFixation.y[0][0] + Math.round(Math.random()*(boundingBoxesFixation.y[0][1] - boundingBoxesFixation.y[0][0]))

			touchhold_return.cxyt = [0,x,y,Date.now() - ENV.CurrentDate.valueOf()]

			FLAGS.waitingforTouches--
		}//IF automated stress test
		else {
            if (TASK.FixationUsesSample <= 0){
                var p1 = hold_promise(TASK.FixationDuration,boundingBoxesFixation,FLAGS.punishOutsideTouch)
            }
            else if (TASK.FixationUsesSample > 0){
                var p1 = hold_promise(TASK.FixationDuration,boundingBoxesChoice3D,FLAGS.punishOutsideTouch)
            }
			var p2 = choiceTimeOut(TASK.FixationTimeOut)
			var touchhold_return = await Promise.race([p1,p2])

			//So that sample movie does not continue playing after fixation acquired
			frame.current = frame.shown.length
			frame.shown[frame.current] = 1
		}//ELSE await fixation hold

		CURRTRIAL.fixationtouchevent = touchhold_return.type
		CURRTRIAL.fixationxyt = [touchhold_return.cxyt[1], touchhold_return.cxyt[2], touchhold_return.cxyt[3]]
		CURRTRIAL.allfixationxyt[TASK.NFixations - FLAGS.waitingforTouches - 1] = CURRTRIAL.fixationxyt

		logEVENTS("FixationTouchEvent",CURRTRIAL.fixationtouchevent,"trialseries")
		logEVENTS("FixationXYT",CURRTRIAL.fixationxyt,"trialseries")

		if (CURRTRIAL.fixationtouchevent == "theld"){
			if (TASK.RewardStage == 0 && FLAGS.waitingforTouches == 0){
				CURRTRIAL.response = CURRTRIAL.correctitem
				logEVENTS("Response",CURRTRIAL.response,"trialseries")
			}
		}//IF held fixaiton & fixation task, count as correct
		else if (TASK.RewardStage == 0 && CURRTRIAL.fixationtouchevent == "tbroken"){
			CURRTRIAL.response = -1
			FLAGS.waitingforTouches = 0 //exit loop
			logEVENTS("Response",CURRTRIAL.response,"trialseries")
		}//IF broke fixation & fixation task, count as incorrect
		else if ( (CURRTRIAL.fixationtouchevent == "tbroken" && TASK.RewardStage == 1)
              || (CURRTRIAL.fixationtouchevent == "TimeOut")){
        }//IF timed out OR dms task, ok if touched outside, just wait for touch inside fixation area

		//========= AWAIT CLEAR FIXATION =========//
		for (var q in CANVAS.sequenceblank){frame.shown[q]=0; frame.frames[q]=[q] }
		frame.current=0;
		if (FLAGS.waitingforTouches > 0){
			await displayTrial(CANVAS.tsequenceblank,[-1,-1],[0,1],CANVAS.sequenceblank,[0,0],[0,0])
		}//blank out screen
	}//WHILE waiting for NFixations
	//============ (end) WHILE RUN FIXATION SCREEN ============//


//SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    //
//SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    //
//SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    SAMPLE TEST    //
	//============== AWAIT SHOW SAMPLE THEN TEST ==============//
	if (TASK.RewardStage === 1){

        //Set where to display
        if (TASK.SampleGridIndex > 0){
          CURRTRIAL.samplegridindex = TASK.SampleGridIndex;
        }//IF fixed sample location
        else if (TASK.SampleGridIndex < 0){
          if (TASK.FixationGridIndex < 0){
              CURRTRIAL.samplegridindex = CURRTRIAL.fixationgridindex
          }//IF moving fixation, use its grid location for sample
          else {
              CURRTRIAL.samplegridindex = Math.floor((ENV.XGridCenter.length)*Math.random()); 
          }//ELSE use random grid location for sample

          //Update grid location of each Sample frame
          for (var i=0; i<=CURRTRIAL.sequencegridindex.length-1; i++){
            for (var j=0; j<=CURRTRIAL.sequencegridindex[i].length-1; j++){
                if (CURRTRIAL.sequencetaskscreen[i] == "Sample"){
                    CURRTRIAL.sequencegridindex[i][j] = CURRTRIAL.samplegridindex
                }//IF Sample
            }//FOR j display items
          }//FOR i frames
        }//ELSE IF random sample location
        logEVENTS("SampleGridIndex",CURRTRIAL.samplegridindex,"trialseries")

        frame.shown=[]
        frame.frames=[]
        frame.current=0
        for (var q in CURRTRIAL.sequencetaskscreen){
            frame.shown[q]=0
            frame.frames[q]=[q]
        }//FOR q frames

        //Add KeepSampleON & KeepTestON
        if (TASK.KeepSampleON == 1){
            var indices = []
            var idx = CURRTRIAL.sequencetaskscreen.indexOf("Sample");
            while (idx != -1) {
                indices.push(idx);
                idx = CURRTRIAL.sequencetaskscreen.indexOf("Sample", idx + 1);
            }//WHILE
            for (var i=indices[indices.length-1]+1; i<=frame.frames.length-1; i++){
                frame.frames[i].push(indices[indices.length-1]) //Append last Sample scene rendered
            }//FOR i remaining frames after Sample
        }//IF KeepSampleON

        if (TASK.KeepTestON == 1 && TASK.SameDifferent > 0){
            var indices = []
            var idx = CURRTRIAL.sequencetaskscreen.indexOf("Test");
            while (idx != -1) {
                indices.push(idx);
                idx = CURRTRIAL.sequencetaskscreen.indexOf("Test", idx + 1);
            }//WHILE
            for (var i=indices[indices.length-1]+1; i<=frame.frames.length-1; i++){
                frame.frames[i].push(indices[indices.length-1]) //Append last Test scene rendered
            }//FOR i remaining frames after Test
        }//IF KeepSampleON

        //Display Sample & Test/Choice
        if (TASK.NRSVP>0 && TASK.SampleFixationSizeInches>0){
            funcreturn = getSampleFixationBoundingBox(CURRTRIAL.samplegridindex,ENV.SampleFixationRadius)
            boundingBoxesSampleFixation.x[0] = funcreturn[0]
            boundingBoxesSampleFixation.y[0] = funcreturn[1]
            FLAGS.punishOutsideTouch = 1
            FLAGS.waitingforTouches = 1
            FLAGS.acquiredTouch = 1;
            var p1 = hold_promise(0,boundingBoxesSampleFixation,FLAGS.punishOutsideTouch)
            var p2 = displayTrial(CURRTRIAL.tsequence, CURRTRIAL.sequencegridindex, CURRTRIAL.sequenceframe, CURRTRIAL.sequencetaskscreen, CURRTRIAL.sequencelabel, CURRTRIAL.sequenceindex)
            CURRTRIAL.samplestarttime=Date.now() - ENV.CurrentDate.valueOf();
            CURRTRIAL.samplestarttime_string = new Date(Date.now()).toJSON()
            var race_return = await Promise.race([p1,p2])
            FLAGS.acquiredTouch = 0;
            FLAGS.waitingforTouches = 0
            if (TASK.TrackEye > 0){
                ENV.Eye.EventType = "eyestart" //Reset eye state
            }//IF TrackEye

            if (typeof(race_return.type) == "undefined"){
                CURRTRIAL.samplefixationtouchevent = 'theld'
                CURRTRIAL.samplefixationxyt = [0,0,CURRTRIAL.tsequenceactual[CURRTRIAL.tsequenceactual.length-1]]
            }//IF held samplefixation
            else{
                CURRTRIAL.samplefixationtouchevent = race_return.type
                CURRTRIAL.samplefixationxyt = [race_return.cxyt[1], race_return.cxyt[2], race_return.cxyt[3]]
            }//ELSE broke samplefixation
        }//IF RSVP, hold sample fixation
        else{
			boundingBoxesChoice3D = {'x':[],'y':[]} //determined on the fly during display
	        CURRTRIAL.samplefixationtouchevent = ''
            CURRTRIAL.samplefixationxyt = []
			await displayTrial(CURRTRIAL.tsequence, CURRTRIAL.sequencegridindex, CURRTRIAL.sequenceframe,
								CURRTRIAL.sequencetaskscreen, CURRTRIAL.sequencelabel, CURRTRIAL.sequenceindex)
        }//ELSE !RSVP, no fixation hold
        logEVENTS("SampleFixationTouchEvent",CURRTRIAL.samplefixationtouchevent,"trialseries")
        logEVENTS("SampleFixationXYT",CURRTRIAL.samplefixationxyt,"trialseries")

        //Store timing of clip presentations
        CURRTRIAL.tsequencedesiredclip = []
        CURRTRIAL.tsequenceactualclip = []
        for (var f=0; f<=CURRTRIAL.sequencetaskscreen.length-1; f++){
            if (f==0 || CURRTRIAL.sequencetaskscreen[f] != CURRTRIAL.sequencetaskscreen[f-1] || CURRTRIAL.sequenceclip[f] != CURRTRIAL.sequenceclip[f-1])
            {               	
               	CURRTRIAL.tsequencedesiredclip.push(CURRTRIAL.tsequence[f])
                if (f > CURRTRIAL.tsequenceactual.length-1){
                    CURRTRIAL.tsequenceactualclip.push(-1)
                }//IF clip not shown
                else{
                    CURRTRIAL.tsequenceactualclip.push(CURRTRIAL.tsequenceactual[f])
                }//ELSE clip shown
            }//IF new clip || new taskscreen within that clip
        }//FOR f frames
    	logEVENTS("TSequenceDesiredClip",CURRTRIAL.tsequencedesiredclip,"trialseries")
    	logEVENTS("TSequenceActualClip",CURRTRIAL.tsequenceactualclip,"trialseries")
        logEVENTS("SampleStartTime",CURRTRIAL.samplestarttime,"trialseries")
        logEVENTS("FrameNum",CURRTRIAL.sequenceframe,'timeseries')
        logEVENTS("TSequenceDesired",CURRTRIAL.tsequence,"timeseries")
        logEVENTS("TSequenceActual",CURRTRIAL.tsequenceactual,"timeseries")

        //Store timestamp from beginnning of display
        EVENTS["timeseries"]["FrameNum"][Object.keys(EVENTS["timeseries"]["FrameNum"]).length-1][1] = CURRTRIAL.samplestarttime_string
        EVENTS["timeseries"]["TSequenceDesired"][Object.keys(EVENTS["timeseries"]["TSequenceDesired"]).length-1][1] = CURRTRIAL.samplestarttime_string
        EVENTS["timeseries"]["TSequenceActual"][Object.keys(EVENTS["timeseries"]["TSequenceActual"]).length-1][1] = CURRTRIAL.samplestarttime_string

		audiocontext.suspend()

//RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    //
//RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    //
//RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    RESPONSE    //
        //========= AWAIT TOUCH RESPONSE =========//
		FLAGS.waitingforTouches = 1
		if (TASK.HideTestDistractors >= 1){
			FLAGS.punishOutsideTouch = 1
		}
		else {
			FLAGS.punishOutsideTouch = 0			
		}

		if (FLAGS.stressTest == 1){
			var race_return = {type: "theld"}

			var nchoices = boundingBoxesChoice3D.x.length
			// var currchoice = CURRTRIAL.correctitem
			var hitrate = 0
			if (TASK.Agent == "Youno"){
				hitrate = 0.9
			}
			else if (TASK.Agent == "Eliaso"){
				hitrate = 0.7
			}
			else if (TASK.Agent == "SaveImages"){
				hitrate = 1.0
			}
			if (Math.random() < hitrate){
				var currchoice = CURRTRIAL.correctitem
			}
			else {
				var distractor_array = []
				for (var i=0; i<=nchoices-1; i++){
					if (i != CURRTRIAL.correctitem){
						distractor_array.push(i)
					}
				}
				distractor_array = shuffle(distractor_array)
				var currchoice = distractor_array[0]
			}

			var x = boundingBoxesChoice3D.x[currchoice][0] + Math.round(Math.random()*(boundingBoxesChoice3D.x[currchoice][1] - boundingBoxesChoice3D.x[currchoice][0]))

			var y = boundingBoxesChoice3D.y[currchoice][0] + Math.round(Math.random()*(boundingBoxesChoice3D.y[currchoice][1] - boundingBoxesChoice3D.y[currchoice][0]))

			race_return.cxyt = [currchoice,x,y,Date.now() - ENV.CurrentDate.valueOf()]

			FLAGS.waitingforTouches--
		}//IF StressTest
		else {
            if (TASK.NRSVP > 0){
            	CURRTRIAL.correctitem = 1
                if (TASK.SampleFixationSizeInches <= 0){
                    var race_return = {type: "theld"}
                    var currchoice = 1
                }//IF no fixation required
                else {
                    var race_return = {type: CURRTRIAL.samplefixationtouchevent}

                    if (CURRTRIAL.samplefixationtouchevent == "theld"){
                        var currchoice = 1
                    }//IF held samplefixation
                    else {
                        var currchoice = 0
                    }//ELSE broke samplefixation
                }//ELSE fixation required

                race_return.cxyt = [currchoice,-1,-1,CURRTRIAL.samplefixationxyt[2]]
                FLAGS.waitingforTouches--            
            }//IF RSVP, skip choice
            else{
                var p1 = hold_promise(0,boundingBoxesChoice3D,FLAGS.punishOutsideTouch)
                var p2 = choiceTimeOut(TASK.ChoiceTimeOut)

                var race_return = await Promise.race([p1,p2])
            }//ELSE require choice
		}//ELSE

		CURRTRIAL.responsetouchevent = race_return.type
		CURRTRIAL.response = race_return.cxyt[0]
		CURRTRIAL.responsexyt = [race_return.cxyt[1], race_return.cxyt[2], race_return.cxyt[3]]

		logEVENTS("ResponseXYT",CURRTRIAL.responsexyt,"trialseries")
		logEVENTS("ResponseTouchEvent",CURRTRIAL.responsetouchevent,"trialseries")
		logEVENTS("Response",CURRTRIAL.response,"trialseries")

		// Keep track of repeated responses to one side
		if (TASK.NRSVP <= 0 && CURRTRIAL.num > 0 && FLAGS.savedata && CURRTRIAL.responsetouchevent == "theld"){
			if (CURRTRIAL.response==trialhistory.response[trialhistory.correct.length-1]){
				FLAGS.stickyresponse++;
			}
			else {
				FLAGS.stickyresponse=0;
			}
		} //IF
	} //if TASK.RewardStage


//REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    //
//REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    //
//REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    REWARD PUNISH    //
  // Determine if Choice was correct
  if (CURRTRIAL.response == CURRTRIAL.correctitem){ CURRTRIAL.correct = 1; }
  else { CURRTRIAL.correct=0; }

	//============ DETERMINE NUMBER OF REWARDS ============//
	if (TASK.RewardStage == 0 && samplereward == 0){
		CURRTRIAL.nreward = -1 //skip reward/punish
	}
	else if ( CURRTRIAL.correct && ( samplereward == -1 || TASK.RewardStage == 0 ) ){ //default behavior
		if (FLAGS.savedata && (CURRTRIAL.starttime - trialhistory.starttime[trialhistory.starttime.length-1] < TASK.ConsecutiveHitsITI || CURRTRIAL.num==0)){
			// if correct within bonus interval
			FLAGS.consecutivehits++
		}
		else {
			// took too long, set to 1
			FLAGS.consecutivehits=1
		}
		CURRTRIAL.nreward = 1 + Math.floor(FLAGS.consecutivehits / TASK.NConsecutiveHitsforBonus)

		if (CURRTRIAL.nreward > TASK.NRewardMax){
			CURRTRIAL.nreward = TASK.NRewardMax
		}
	}
	else if (CURRTRIAL.correct && samplereward >= 1){
		//Override if user had manually set reward for that sample image in image_reward_list file
		CURRTRIAL.nreward = samplereward
	}
	else if (!CURRTRIAL.correct){
			FLAGS.consecutivehits=0;
			CURRTRIAL.nreward = 0;
	} //# of rewards to give

	ENV.RewardDuration = setReward();
	logEVENTS("NReward",CURRTRIAL.nreward,"trialseries")
	
	//============ DELIVER REWARD/PUNISH ============//
	//NO FEEDBACK
	if (  CURRTRIAL.nreward == -1 ){
		CANVAS.sequencepost[1] = "blank";
		CANVAS.tsequencepost[2] = 2*CANVAS.tsequencepost[1];
		frame.shown=[]; frame.frames=[]
		for (var q in CANVAS.sequencepost){frame.shown[q]=0; frame.frames[q]=[q]}; frame.current=0;

		renderShape2D(CANVAS.sequencepost[0],-1,OFFSCREENCANVAS)

		var len = CANVAS.tsequencepost.length
		await displayTrial(CANVAS.tsequencepost,
							Array(len).fill(-1),
							range(0,len-1,1),
							CANVAS.sequencepost,
							Array(len).fill(0),
							Array(len).fill(0)) // dispTrial(time,grid,frame,screen,obj,idx)
	}//IF no feedback
	// REWARD
	else if (CURRTRIAL.correct){
		CANVAS.sequencepost[1]="reward";
		CANVAS.tsequencepost[2] = CANVAS.tsequencepost[1]+ENV.RewardDuration*1000;

		for (var q = 0; q <= CURRTRIAL.nreward-1; q++){
			frame.shown=[]; frame.frames=[]
			for (var q2 in CANVAS.sequencepost){frame.shown[q2]=0; frame.frames[q2] = [q2]}; frame.current=0;

			playSound(2);
			renderShape2D(CANVAS.sequencepost[0],-1,OFFSCREENCANVAS)
			var len = CANVAS.tsequencepost.length
			var p1 = displayTrial(CANVAS.tsequencepost,
								Array(len).fill(-1),
								range(0,len-1,1),
								CANVAS.sequencepost,
								Array(len).fill(0),
								Array(len).fill(0)) // dispTrial(time,grid,frame,screen,obj,idx)
			if (ble.connected == false && port.connected == false){
				await Promise.all([p1])
			}
			else if (ble.connected == true){
				var p2 = writepumpdurationtoBLE(Math.round(ENV.RewardDuration*1000))
				await Promise.all([p1, p2])
			}
			else if (port.connected == true){
				var p2 = port.writepumpdurationtoUSB(Math.round(ENV.RewardDuration*1000))
				await Promise.all([p1, p2])
			}
		} //FOR nrewards
	}//ELSEIF correct, then reward
	//PUNISH
	else if (!CURRTRIAL.correct) {
		CANVAS.sequencepost[1] = "punish";
		CANVAS.tsequencepost[2] = CANVAS.tsequencepost[1]+TASK.PunishTimeOut;
		frame.shown=[]; frame.frames=[]
		for (var q in CANVAS.sequencepost){frame.shown[q]=0; frame.frames[q]=[q]}; frame.current=0;

		renderShape2D(CANVAS.sequencepost[0],-1,OFFSCREENCANVAS)
 		var len = CANVAS.sequencepost.length
		var p1 = displayTrial(CANVAS.tsequencepost,
							Array(len).fill(-1),
							range(0,len-1,1),
							CANVAS.sequencepost,
							Array(len).fill(0),
							Array(len).fill(0)) // dispTrial(time,grid,frame,screen,obj,idx)
		var num_trials_to_buffer_in_punishperiod = 50
        var p2 = TQS.generate_trials(num_trials_to_buffer_in_punishperiod*TASK.RSVP)
		playSound(3);
		await Promise.all([p1,p2])
	}//ELSEIF wrong, then timeout
	//============ (end) DELIVER REWARD/PUNISH ============//


//HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    //
//HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    //
//HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    HOUSEKEEPING    //
	//================= HOUSEKEEPING =================//
	var ITIstart = performance.now()

	// CALIBRATE eye
	if (TASK.TrackEye > 0){
		// Can manually adjust params only when on practice screen
		// Can automatically calibrate when on test screen
		if (FLAGS.savedata == 1 && ENV.Eye.calibration == 1){
				if (CURRTRIAL.fixationtouchevent == 'theld'){
					ENV.Eye.NCalibPointsTrain += 1
				}
				if (ENV.Eye.NCalibPointsTrain == TASK.CalibrateEye){
					// Run calibration fitting 
					var calibreturn = runCallibration()
					ENV.Eye.CalibXTransform = calibreturn.xtform
					ENV.Eye.CalibYTransform = calibreturn.ytform
					ENV.Eye.NCalibPoints = calibreturn.n
					ENV.Eye.CalibType = calibreturn.type

					// Compute GOF
					ENV.Eye.CalibTrainMSE[0] = compute_mse(calibreturn.predictedx,calibreturn.actualx)
					ENV.Eye.CalibTrainMSE[1] = compute_mse(calibreturn.predictedy,calibreturn.actualy)

					// Store calibration
					saveEyeCalibrationtoFirestore(ENV.Eye.CalibXTransform,ENV.Eye.CalibYTransform,ENV.Eye.CalibType,ENV.Eye.NCalibPointsTrain,ENV.Eye.CalibTrainMSE,ENV.Eye.NCalibPointsTest,ENV.Eye.CalibTestMSE)

					ENV.Eye.calibration = 0;
				}//IF enough points
		}//IF train eye calibration
		else if (FLAGS.savedata == 1 && ENV.Eye.calibration == 0){
			if (CURRTRIAL.fixationtouchevent == 'theld'){
				ENV.Eye.NCalibPointsTest += 1
			}//IF held fixation
			if (ENV.Eye.NCalibPointsTest == TASK.CalibrateEye){
				//cross-validate on same number of trials used for training
				ENV.Eye.CalibTestMSE = evaluateCalibration() //GOF test 

				// Store calibration
				saveEyeCalibrationtoFirestore(ENV.Eye.CalibXTransform,ENV.Eye.CalibYTransform,ENV.Eye.CalibType,ENV.Eye.NCalibPointsTrain,ENV.Eye.CalibTrainMSE,ENV.Eye.NCalibPointsTest,ENV.Eye.CalibTestMSE)
			}//IF enough points
		}//ELSE test eye calibration
	}//IF track eye
	
	//clear tracker canvas at end of trial
	// if (FLAGS.savedata == 0){
		EYETRACKERCANVAS.getContext('2d').clearRect(0,0,EYETRACKERCANVAS.width,EYETRACKERCANVAS.height)
	// }//IF practice screen

	CURRTRIAL.lastTrialCompleted = new Date()

	// Update EVENTS only if saving data
	if (FLAGS.savedata == 1){
		// Update trial tracking variables
		updateTrialHistory() //appends to running trial history

		// Run automator
		if (TASK.Automator !=0){	
			await automateTask(automator_data, trialhistory);
		}

		if (TASK.Agent != "SaveImages"){
			// Cloud Storage: Save data asynchronously to json
			saveBehaviorDatatoFirebase(TASK, ENV, CANVAS, EVENTS);

			// Firestore Database: Save data asynchronously to database
			if (FLAGS.createnewfirestore == 1){
				saveBehaviorDatatoFirestore(TASK,ENV,CANVAS); //write once
				pingFirestore() //every 10 seconds, will check for data updates to upload to firestore
			}//IF new firestore, kick off firestore database writes

      // BigQuery Table
      // Save display times asynchronously to BigQuery
      if (CURRTRIAL.num == 0){
          pingBigQueryDisplayTimesTable() //uploads eyedata to bigquery every 10 seconds        
      }//IF first trial, kick-off bigquery writes

      // Save eye data asynchronously to BigQuery
      if (TASK.TrackEye > 0 && CURRTRIAL.num == 0){
          pingBigQueryEyeTable() //uploads eyedata to bigquery every 10 seconds        
      }//IF first trial, kick-off bigquery writes
		}//IF not saving images, save data
	}//IF savedata

	if (FLAGS.need2saveParameters == 1){
		FLAGS.need2saveParameters = saveParameterstoFirebase(); // Save parameters asynchronously
	}

	await checkParameterFileStatusFirebase()
	if ( (new Date).getDate() != ENV.CurrentDate.getDate() || CURRTRIAL.num == 1000){ //in local time
		updateEventDataonFirestore(EVENTS);
		FLAGS.need2loadParameters = 1
	} //if new day, start new file or reached 1000 trials 

	if (TASK.Agent == "SaveImages" && CURRTRIAL.num >= TQS.samplebag_indices.length-1){
		return
	}//IF saved all images

	//================= (end) HOUSEKEEPING =================//

	updateHeadsUpDisplay();
	console.log('End of trial ', CURRTRIAL.num)
	CURRTRIAL.num++
	EVENTS.trialnum = CURRTRIAL.num

	if (typeof(TASK.InterTrialInterval) != "undefined"){
		var remainingInterTrialInterval = TASK.InterTrialInterval - (performance.now() - ITIstart)
		if (remainingInterTrialInterval > 0){
			await sleep(remainingInterTrialInterval)
		}
	}//IF ITI
}
})();

</script>
</body>

</html>