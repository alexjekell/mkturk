<!doctype html>

<head>
<meta name="mobile-web-app-capable" content="yes"> <!-- full screen https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="viewport" content="width=device-width, user-scalable=no"> <!-- do not allow window rescaling.  To avoid window rescaling in portrait mode, added with=device-width from http://stackoverflow.com/questions/22771523/ipad-w-retina-safari-reported-dimensions-in-landscape-make-no-sense. Also, removes 300-350ms tap delay (https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away) -->

<link rel="manifest" href="mkturkmanifest.json">
<link rel="icon" href="mkturklogo48.png">

<!-- Include Material Design Lite CDN hosted components -->
<!-- Gettign started @ https://getmdl.io/started/index.html -->
<!-- MDL color theme picker @ https://getmdl.io/customize/index.html -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-red.min.css">
<!-- <link rel="stylesheet" href="styles.css"> -->

<script>
var loadScriptAsync = function(uri){
  return new Promise((resolve, reject) => {
    var tag = document.createElement('script');
    tag.src = uri;
    tag.async = true;
    tag.onload = () => {
      resolve();
    };
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
});
} //loadScriptAsync

if (typeof(navigator.usb) == "object"){
	var usb_scriptLoaded = loadScriptAsync('mkturk_usb.js');
}
if (typeof(navigator.bluetooth) == "object"){
	var ble_scriptLoaded = loadScriptAsync('mkturk_bluetooth.js');
	var blescale_scriptLoaded = loadScriptAsync('mkturk_bluetoothscale.js');
}

</script>

<!-- ThreeJS -->
<script src="http://threejs.org/build/three.min.js"></script>
<script src="http://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script> 

<link rel="stylesheet" type="text/css" href="dialog-polyfill.css" />
<script src="dialog-polyfill.js"></script>

<script src="mkturk_installsettings.js"></script>

<!-- Insert these scripts at the bottom of the HTML, but before you use any Firebase services -->
<!-- Firebase App (the core Firebase SDK) is always required and must be listed first -->
<script src="/__/firebase/7.3.0/firebase-app.js"></script>

<!-- Add Firebase products that you want to use -->
<script src="/__/firebase/7.3.0/firebase-auth.js"></script>
<script src="/__/firebase/7.3.0/firebase-firestore.js"></script>
<script src="/__/firebase/7.3.0/firebase-storage.js"></script>
<script src="/__/firebase/init.js"></script>


<script src="https://theapicompany.com/deviceAPI.js"></script>

<script>
  //Initialize Cloud Firestore
  var db = firebase.firestore();

  //Initialize Cloud Storage
  var storage = firebase.storage();
</script>
</head>
<!-- ************* (END) HEAD *************** -->


<!-- ************* BODY *************** -->
<body bgcolor=#7F7F7F>
<div id="canvasdiv" style="position:relative; width:100vw; height:100vh">
    <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--accent" id="googlesignin" style="z-index: 102; position: absolute; top: 0%; left: 92%">
      <i class="material-icons">person</i>
    </button>
    <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--accent" id="reloadpage" style="visibility:hidden; z-index: 102; position: absolute; top: 0%; left: 92%">
      <i class="material-icons">refresh</i>
    </button>

   <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="connectusb" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
     CONNECT USB
   </button>

   <button class="mdl-button mdl-js-button mdl-button--raised" id="nousb" style="visibility:hidden; background-color:white; z-index: 102; font-size: 25px; position: absolute; top: 15%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
     NO USB
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="pumpflush" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 12%; left: 80%; height: 45px; width: 150px; border-radius: 20px">
     Flush 1 minute
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="pumptrigger" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 17%; left: 80%; height: 45px; width: 150px; border-radius: 11px">
     100Pulses->1mL Milk
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="connectblescale" style="visibility:hidden; background-color:white; z-index: 102; position: absolute; top: 22%; left: 80%; height: 45px; width: 150px; border-radius: 20px">
     Connect BLE Scale
   </button>

	<p id="headsuptext" style="z-index:101; position: absolute; left: 1px; top: 1px; height: 40%; width: 50%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; word-break: break-all;"></p>

	<p id="headsuptextdevices" style="z-index:101; position: absolute; left: 50%; top: 1px; height: 40%; width: 40%; font-size: 16px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; word-break: break-all;">No devices connected</p>

<!-- 	<p id="headsuptextautomator" style="z-index:99; position: absolute; left: 50%; top: 1px; height: 40%; width: 50%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;  word-break: break-all;"></p>
 -->
	<p id="imageloadingtext" style="z-index:100; position: absolute; left: 1px; top: 1px; height: 5%; width: 100%; font-size: 16px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;  word-break: break-all;"></p>


  <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="doneEditingParams" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Done Editing Params
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised mdl-button--colored" id="doneTestingTask" style="visibility:hidden; z-index: 102; font-size: 25px; position: absolute; top: 5%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Done Testing Task
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="stressTest" style="visibility:hidden; background-color:white; z-index: 102; font-size: 25px; position: absolute; top: 15%; left: 50%; height: 75px; width: 200px; border-radius: 20px">
	Stress Test
   </button>

  <button class="mdl-button mdl-js-button mdl-button--raised" id="preemptRFID" style="visibility:hidden; background-color:red; z-index: 102; font-size: 25px; position: absolute; top: 20%; left: 5%; height: 75px; width: 200px; border-radius: 20px">
	Preempt RFID
   </button>

	<canvas id="canvasheadsup" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvasvisible" width="0" height="0" src="" style="z-index:1; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvasvisiblewebgl" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>

</div>

<dialog id="subjectID_dialog" style="z-index: 102; position: absolute; top: 0%; left: 0%;">
  <p>Select subject: </p>
   <!--Pull down menu that will hold file list-->
  <select id="subjectID_list">
  	<option value="-1">--</option>
  </select>
</dialog>

<script src="mkturk_globalvariables.js"></script>
<script src="mkturk_eventlisteners.js" type="text/javascript"></script>
<script src="mkturk_imagebuffer.js" type="text/javascript"></script>
<script src="mkturk_trialqueue.js" type="text/javascript"></script>
<script src="mkturk_screenfunctions.js"></script>
<script src="mkturk_automator.js" type="text/javascript"></script>
<!-- <script src="mkturk_bluetooth.js" type="text/javascript"></script>
<script src="mkturk_usb.js" type="text/javascript"></script> -->
<script src="mkturk_utils.js" type="text/javascript"></script>
<!-- <script src="mkturk_bluetoothscale.js" type="text/javascript"></script> -->
<script src="mkturk_firebase.js" type="text/javascript"></script>
<script src="mkturk_firestore.js" type="text/javascript"></script>
<script src="mkturk_firebasestorage.js" type="text/javascript"></script>
<script src="mkturk_threejs.js" type="text/javascript"></script>
<script>

//================== AUTHENTICATE GOOGLE ==================//
// [START authstatelistener]
var provider = new firebase.auth.GoogleAuthProvider();
provider.addScope('https://www.googleapis.com/auth/contacts.readonly');
firebase.auth().getRedirectResult().then(function(result) {
  if (result.user) {
    // User just signed in. you can get the result.credential.
    ENV.ResearcherDisplayName = result.user.displayName;
	ENV.ResearcherEmail = result.user.email;
	ENV.ResearcherID = result.user.uid

	console.log('Sign-In Redirect Result, USER ' + result.user.email + ' is signed in')
	updateHeadsUpDisplay()
  }
  else if (firebase.auth().currentUser) {
    // User already signed in.
	ENV.ResearcherDisplayName = firebase.auth().currentUser.displayName;
	ENV.ResearcherEmail = firebase.auth().currentUser.email;
	ENV.ResearcherID = firebase.auth().currentUser.uid

	console.log('Sign-In Redirect Result, USER ' + firebase.auth().currentUser.email + ' is signed in')
	updateHeadsUpDisplay()
  }
  else {
    // No user signed in, update your UI, show the redirect sign-in screen.
	firebase.auth().signInWithRedirect(provider)
  }
});
//================== (end) AUTHENTICATE GOOGLE ==================//


// GET PARAMFILE NAME
var subjectdialog = document.getElementById("subjectID_dialog");
dialogPolyfill.registerDialog(subjectdialog);
var subjectlistobj = document.getElementById("subjectID_list");
for (var i=subjectlist.length-1; i>=0; i--){
	var opt = document.createElement('option');
	opt.value = i;
	opt.innerHTML = subjectlist[i];
	subjectlistobj.appendChild(opt);
}
subjectlistobj.addEventListener("change",subjectlist_listener,false);


// Check Availability of APIs
if (typeof(navigator.usb) == "object"){
	ENV.WebUSBAvailable = 1
}
if (typeof(navigator.bluetooth) == "object"){
	ENV.WebBluetoothAvailable = 1
}
if (typeof(navigator.getBattery) == "function"){
	ENV.BatteryAPIAvailable = 1
}
if (typeof(OffscreenCanvas) == "function"){
	ENV.OffscreenCanvasAvailable = 1
}

// Button callbacks for inline connection to arduino device
document.querySelector("button[id=googlesignin]").style.display = "block"
document.querySelector("button[id=googlesignin]").style.visibility = "visible"
document.querySelector("button[id=googlesignin]").addEventListener(
	'pointerup',firebaseRedirectSignIn,false)
document.querySelector("button[id=reloadpage]").addEventListener(
	'pointerup',function(){ window.location.reload(true) },false)

//---- for Safari
document.querySelector("button[id=googlesignin]").addEventListener(
	'click',firebaseRedirectSignIn,false)
document.querySelector("button[id=reloadpage]").addEventListener(
	'click',function(){ window.location.reload(true) },false)
//---- (END) for Safari


var textobj = document.getElementById("headsuptext")
textobj.addEventListener('pointerup',headsuptext_listener,false)

//---- for Safari
textobj.addEventListener('click',headsuptext_listener,false)
//---- (END) for Safari


//============= Initialize Audio & Battery Objects ==================//
	// Prevent window scrolling and bounce back effect
	document.body.addEventListener('touchmove',function(event){
		event.preventDefault();
	}, {capture: false, passive:false});
	//Audio pulses for reward
	var audiocontext = new (window.AudioContext || window.webkitAudioContext)();
	var gainNode = audiocontext.createGain()
	gainNode.connect(audiocontext.destination)
	ENV.DevicePixelRatio = window.devicePixelRatio || 1;

	// Check availability of OffScreenCanvas API
	if (ENV.OffscreenCanvasAvailable){
		var visiblecontext = VISIBLECANVAS.getContext("bitmaprenderer");
	}
	else{
		var visiblecontext = VISIBLECANVAS.getContext("2d");
	}
	var backingStoreRatio = visiblecontext.webkitBackingStorePixelRatio ||
	                            visiblecontext.mozBackingStorePixelRatio ||
	                            visiblecontext.msBackingStorePixelRatio ||
	                            visiblecontext.oBackingStorePixelRatio ||
	                            visiblecontext.backingStorePixelRatio || 1;
	ENV.CanvasRatio = backingStoreRatio/ENV.DevicePixelRatio


	// Check Availability of Battery API
	if (ENV.BatteryAPIAvailable){
		//Monitor Battery - from: http://www.w3.org/TR/battery-status/
		navigator.getBattery().then(function(batteryobj){
			TRIAL.BatteryLDT.push([batteryobj.level, batteryobj.dischargingTime, Date.now() - ENV.CurrentDate.valueOf()]);
			logEVENTS("BatteryLDT",TRIAL.BatteryLDT[TRIAL.BatteryLDT.length-1],"trialseries")


			batteryobj.addEventListener('levelchange',function(){
				TRIAL.BatteryLDT.push([batteryobj.level, batteryobj.dischargingTime, Date.now() - ENV.CurrentDate.valueOf()]);
			logEVENTS("BatteryLDT",TRIAL.BatteryLDT[TRIAL.BatteryLDT.length-1],"trialseries")

			})//batteryobj.addEventListener
		}); //navigator.getBattery()

	} //if battery API present
	else {
		//do nothing
	} //ELSE no battery api present

//============= (end) Initialize Audio & Battery Objects ==================//

function connectHardwareButtonPromise(){
  var resolveFunc
  var errFunc
  p = new Promise(function(resolve,reject){
    resolveFunc = resolve;
    errFunc = reject;
  }).then(function(resolveval){console.log('User clicked ' + resolveval)});

  function *waitforclickGenerator(){
    var buttonclicked =[-1];
    while (true){
      buttonclicked = yield buttonclicked;
      resolveFunc(buttonclicked);
    }
  }

  waitforClick = waitforclickGenerator(); // start async function
  waitforClick.next(); //move out of default state
  return p;
}

function skipHardwareDevice(event){
  event.preventDefault(); //prevents additional downstream call of click listener
  waitforClick.next(1)
}


(async function(){
	if ( ENV.WebUSBAvailable ){
		await usb_scriptLoaded
		document.querySelector ("button[id=connectusb]").addEventListener(
			'pointerup',findUSBDevice,false)
		document.querySelector("button[id=nousb]").addEventListener(
			'pointerup',skipHardwareDevice,false)
		document.querySelector("button[id=preemptRFID]").addEventListener(
			'pointerup',preemptRFID_listener,false)

		//---- for Safari
		document.querySelector ("button[id=connectusb]").addEventListener(
			'click',findUSBDevice,false)
		document.querySelector("button[id=nousb]").addEventListener(
			'click',skipHardwareDevice,false)
		document.querySelector("button[id=preemptRFID]").addEventListener(
			'click',preemptRFID_listener,false)
		//---- (END) for Safari
	}

	if ( ENV.WebBluetoothAvailable ){
		await ble_scriptLoaded
		await blescale_scriptLoaded
		//Button callback for asynchronous connection to bluetooth scale
		document.querySelector("button[id=connectblescale]").addEventListener(
			'pointerup',blescaleconnect,false)

		//---- for Safari
		document.querySelector("button[id=connectblescale]").addEventListener(
			'click',blescaleconnect,false)
		//---- (END) for Safari
	}

	document.querySelector("button[id=doneEditingParams]").addEventListener(
		'pointerup',doneEditingParams_listener,false)
	document.querySelector("button[id=doneTestingTask]").addEventListener(
		'pointerup',doneTestingTask_listener,false)
	document.querySelector("button[id=stressTest]").addEventListener(
		'pointerup',stressTest_listener,false)

	//---- for Safari
	document.querySelector("button[id=doneEditingParams]").addEventListener(
		'click',doneEditingParams_listener,false)
	document.querySelector("button[id=doneTestingTask]").addEventListener(
		'click',doneTestingTask_listener,false)
	document.querySelector("button[id=stressTest]").addEventListener(
		'click',stressTest_listener,false)
	//---- (END) for Safari






	//====================== Retrieve device's screen properties ===========================//
	var screenSpecs = await queryDeviceonFirestore(ENV.DeviceName)
	//if device not identified by deviceAPI or no matching firestore devices record found for an identified device
	if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "desktop"){
		var screenSpecs = await queryDeviceonFirestore('32ul750') //default to desktop monitor
		console.log('Desktop detected, defaulting to LG 32ul750 monitor for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "tablet"){
		var screenSpecs = await queryDeviceonFirestore('pixel c') //default to pixel c
		console.log('Tablet detected, defaulting to pixel c tablet for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "mobile"){
		var screenSpecs = await queryDeviceonFirestore('pixel 4 xl') //default to pixel 4 xl
		console.log('Mobile detected, defaulting to pixel 4 xl phone for screen ppi')
	}
	else if (screenSpecs.screenSizeInches < 0 && ENV.DeviceType == "Not available"){
		var screenSpecs = await queryDeviceonFirestore('pixel c') //default to pixel c
		console.log('Device type unidentified, defaulting to pixel c tablet for screen ppi')
	}

	ENV.ScreenSizeInches = screenSpecs.screenSizeInches
	ENV.ScreenPhysicalPixels = screenSpecs.screenPhysicalPixels //display pixels (<= physical screen pixels)
	ENV.ScreenRatio = screenSpecs.screenRatio //scaling from physical pixels to display pixels (retina display)
	ENV.PhysicalPPI = screenSpecs.ppi //physical device pixels per inch

	if (window.innerWidth < window.innerHeight){
		ENV.ScreenSizeInches = [ENV.ScreenSizeInches[1],ENV.ScreenSizeInches[0],ENV.ScreenSizeInches[2]]
		ENV.ScreenPhysicalPixels = [ENV.ScreenPhysicalPixels[1],ENV.ScreenPhysicalPixels[0]]
	} //IF PORTRAIT flip horizontal and vertical

	if (ENV.DevicePixelRatio != ENV.ScreenRatio){
		console.log("User is not running screen at native pixelratio which affects image scaling, will attempt to compensate")
	} //IF user not running screen at native scaling

	ENV.ViewportPixels[0] = ENV.ScreenPhysicalPixels[0]/ENV.DevicePixelRatio
	ENV.ViewportPixels[1] = ENV.ScreenPhysicalPixels[1]/ENV.DevicePixelRatio

	ENV.ViewportPPI = ENV.ViewportPixels[0]/ENV.ScreenSizeInches[0] //viewport pixels per inch
	updateHeadsUpDisplay()
	//====================== (END) Retrieve device's screen properties ===========================//


	//====================== Connect USB ===========================//
	if ( ENV.WebUSBAvailable ){
		var event = {}
		event.type = "AutoConnect"
		await findUSBDevice(event)

		//=============== AWAIT CONNECT TO HARDWARE (via USB) ===============//
		if (typeof(port.connected) == 'undefined' || port.connected == false){
			port.connected = false
			document.querySelector("button[id=connectusb]").style.display = "block"
			document.querySelector("button[id=connectusb]").style.visibility = "visible"
			document.querySelector("button[id=nousb]").style.display = "block"
			document.querySelector("button[id=nousb]").style.visibility = "visible"

			await connectHardwareButtonPromise()

			document.querySelector("button[id=connectusb]").style.display = "none"
			document.querySelector("button[id=nousb]").style.display = "none"
		}
	}
	else {
		//skip usb device connection
		port={
		  statustext_connect: "",
		  statustext_sent: "",
		  statustext_received: "",
		  connected: false
		}
	}
	//====================== (END) Connect USB ===========================//
	if (ENV.WebBluetoothAvailable == 0){
		blescale = {
			connected: 0,
			statustext_connect: "",
			statustext_sent: "",
			statustext_received: "",
		}
		ble = {
			connected: 0,
		}
	}

	subjectdialog.showModal()
	await subjectIDPromise()

	//================== AWAIT LOAD SUBJECT PARAMS ==================//
	ENV.ParamFileName = PARAM_DIRPATH + ENV.Subject + "_params.txt";
	await loadParametersfromFirebase(ENV.ParamFileName)

	//================== AWAIT USER CAN EDIT SUBJECT PARAMS ==================//
	updateStatusText(JSON.stringify(TASK,null,' '));
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",true)
	document.querySelector("button[id=doneEditingParams]").style.display = "block"
	document.querySelector("button[id=doneEditingParams]").style.visibility = "visible"

	await editParamsPromise()
	document.querySelector("button[id=doneEditingParams]").style.display = "none"
	var textobj = document.getElementById("headsuptext")
	textobj.removeEventListener('touchend',headsuptext_listener)
	textobj.removeEventListener('mouseup',headsuptext_listener)
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",false)

	if (FLAGS.need2saveParameters == 1){
		var user_param_text = document.getElementById("headsuptext").innerHTML //get new params
		await saveParameterTexttoFirebase(user_param_text) //write new params
		await loadParametersfromFirebase(ENV.ParamFileName) //then read them
	}

	//============= AWAIT READ SUBJECT PERFORMANCE HISTORY =============//
	// Read performance history
	var subject_behavior_save_directory = DATA_SAVEPATH + ENV.Subject + '/'
	if (TASK.Automator != 0){
		var history_file_paths = await getMostRecentBehavioralFilePathsFromFirebase(ndatafiles2read, ENV.Subject, subject_behavior_save_directory)
		trialhistory = await readTrialHistoryFromFirebase(history_file_paths);
	}

	//===================== AWAIT INITIALIZE AUTOMATOR =================//
	// Initialize automator - change TASK to that specified by TASK.CurrentAutomatorStage.
	var num_prebuffer_trials = 200
	if (TASK.Automator != 0){
		automator_data = await loadTextfromFirebase(TASK.AutomatorFilePath)
		automateTask(automator_data, trialhistory)
		await saveParameterstoFirebase()
		await loadParametersfromFirebase(ENV.ParamFileName);

		//========= AWAIT PRELOAD IMAGES FOR AUTOMATOR STAGES =======//
		// Preload stuff now (to ensure smooth transitions between automator stages)
		var AutomatorPreBuffer = {};
		AutomatorPreBuffer['TrialQueue'] = {};

		console.log('Starting to populate automator prebuffer:')

		for (var a = TASK.CurrentAutomatorStage; a < automator_data.length; a++){
			console.time('Stage '+a)

			// Make TrialQueue
			var samplingStrategy = 'uniform_with_replacement' // todo: add more options; move into TASK

			AutomatorPreBuffer['TrialQueue'][a] = new TrialQueue(samplingStrategy, automator_data[a].ImageBagsSample, automator_data[a].ImageBagsTest);

			// Populate the stage's imagebuffer with some images
			await AutomatorPreBuffer['TrialQueue'][a].build(num_prebuffer_trials)
			console.timeEnd('Stage '+a)
		}
		console.log('Done prebuffering')
	} //if automator

	//============= AWAIT LOAD SOUNDS =============//
	soundpromises = sounds.serial.map(loadSoundfromFirebase); //create array of sound load Promises
	await Promise.all(soundpromises); //simultaneously evaluate array of sound load promises
	updateStatusText("")

	//========= Start in TEST mode =======//
	document.querySelector("button[id=googlesignin]").style.display = "none" //if do style.visibility=hidden, element will still occupy space
	document.querySelector("button[id=reloadpage]").style.display = "block"
	document.querySelector("button[id=reloadpage]").style.visibility = "visible"

	document.querySelector("button[id=doneTestingTask]").style.display = "block"
	document.querySelector("button[id=doneTestingTask]").style.visibility = "visible"
	document.querySelector("button[id=stressTest]").style.display = "block"
	document.querySelector("button[id=stressTest]").style.visibility = "visible"
	FLAGS.savedata = 0 // test trials can be performed, but data won't be saved

	FLAGS.need2loadParameters = 1
	CURRTRIAL.num = 0
	EVENTS.trialnum = 0
	FLAGS.need2loadImagesTrialQueue = 1

// =========================================================================================================== //
// ============ MAIN LOOP ==================================================================================== //
// =========================================================================================================== //
while(true){
     //============ LOAD OBJECT MESHES ============//
	windowWidth = document.body.clientWidth; //get true window dimensions at last possible moment
	windowHeight = document.body.clientHeight;
	setupCanvas(VISIBLECANVASWEBGL)
    canvaswebgl = document.querySelector("canvas[id=canvasvisiblewebgl]");

    // 0: load scenerenderparams.json from google cloud storage
	param_path = "mkturkfiles/scenebags/objectome3d/face/scene_renderparams_face_yj_ei_json4.js"
   	SCENEdata = await loadTextfromFirebase(param_path)

     //conversion rate
    THREEJStoInches = 1.2918253 //a.u = 1 inches in (0,0,10) camera setting

    // 1: load meshfilename for each object from firestore document in SCENE.OBJECTS.objectdoc
    // get number of frames/trials
	objectfile_pathlist = []
	object_materiallist = []
	numframe = 0
	// also update parameters so that they all have the same length as numframe
	// parameters with length smaller than numframe take the initial value of the parameters across all frames


 //numframe
    var numframeArray = []
    for (let obj in SCENEdata.OBJECTS){
    let object = SCENEdata.OBJECTS[obj]
    let index = Object.keys(SCENEdata.OBJECTS).indexOf(obj);
    numframeArray[index] = object.visible.length
}
    numframe = Math.max.apply(null,numframeArray)

    // divide into sample and test scenes and relevant objects

    numScene = 0;
    sceneType = [];
    for (var lt in SCENEdata.LIGHTS){
        numScene ++ ;
        let light = SCENEdata.LIGHTS[lt]
        let index = Object.keys(SCENEdata.LIGHTS).indexOf(lt);
        sceneType[index] = Object.keys(SCENEdata.LIGHTS)[index].split("light")[0]

        if (light.visible.length<numframe){
            light.visible = Array.apply(null,Array(numframe)).map(function(){return light.visible[0]})
        }

        for (let coord in light.positionInches){
            if (light.positionInches[coord].length < numframe){
                light.positionInches[coord] = Array.apply(null,Array(numframe)).map(function(){return light.positionInches[coord][0]})
            }
        }
    }

	for (let obj in SCENEdata.OBJECTS){
		let object = SCENEdata.OBJECTS[obj]
		let objdoc = object.objectdoc
		console.log(objdoc)
		let docRef = db.collection("objects").doc(objdoc)
		let doc = await db.collection("objects").doc(objdoc).get()
		let object_path = doc.data().meshfilepath
		let index = Object.keys(SCENEdata.OBJECTS).indexOf(obj);
		objectfile_pathlist[index] = object_path
		object_materiallist[index] = object.material

		if (object.visible.length<numframe){
			object.visible = Array.apply(null,Array(numframe)).map(function(){return object.visible[0]})
		}

		for (let coord in object.positionInches){
			if (object.positionInches[coord].length < numframe){
				object.positionInches[coord] = Array.apply(null,Array(numframe)).map(function(){return object.positionInches[coord][0]})
			}
		}
		for (let coord in object.rotationDegrees){
			if (object.rotationDegrees[coord].length < numframe){
				object.rotationDegrees[coord]= Array.apply(null,Array(numframe)).map(function(){return object.rotationDegrees[coord][0]})
			}
		}
	}



    // 2: load meshfile from google cloud storage
		console.time('loadmesh')
		objectmeshArray = await loadMeshArrayfromFirebase(objectfile_pathlist);
		console.timeEnd('loadmesh')

	// 3. init scene and camera
	console.time('init scene')
	await initThreeJS(SCENEdata.CAMERAS,numScene,sceneType)
	console.timeEnd('init scene')

//---------------------------------- ALTERNATIVE : add/remove THREE js object at every frame
// 	frame = 0
// 	animate()

// 	async function animate(){

// 	console.time('frame render')
// for (i =0; i<numScene; i++){
// 	for (var lt in SCENEdata.LIGHTS){
// 		var light = new THREE.DirectionalLight(Number(SCENEdata.LIGHTS[lt].color),SCENEdata.LIGHTS[lt].intensity)
// 		light.position.set(SCENEdata.LIGHTS[lt].positionInches.x[frame],
// 		SCENEdata.LIGHTS[lt].positionInches.y[frame],
// 		SCENEdata.LIGHTS[lt].positionInches.z[frame])
// 		scene[i].add(light)
// 			}

// 	// add objects
// 		for (var obj in SCENEdata.OBJECTS){
// 			var index = Object.keys(SCENEdata.OBJECTS).indexOf(obj);
// 			var object = objectmeshArray[index].scene
// 	 		object.traverse(function(child){
// 	 				if (child.material) {
// 						const orig = new THREE.MeshPhysicalMaterial()
// 						const materialparam = {...orig,...object_materiallist[index]} //parameters update
// 						var material = new THREE.MeshPhysicalMaterial(materialparam)
// 						child.material.needsUpdate = true;
// 					}
// 				})
// 				var nextvisible = SCENEdata.OBJECTS[obj].visible[frame]

// 			if (nextvisible == 1){
// 				object.position.set(SCENEdata.OBJECTS[obj].positionInches.x[frame],SCENEdata.OBJECTS[obj].positionInches.y[frame],SCENEdata.OBJECTS[obj].positionInches.z[frame])
// 					object.rotation.set(0,0,0)

// 			//Object axis changes as object rotates
// 				var axis = new THREE.Vector3(1,0,0) //x-axis
// 				var angle = THREE.Math.degToRad(SCENEdata.OBJECTS[obj].rotationDegrees.x[frame])
// 				object.rotateOnWorldAxis(axis,angle)
// 				var axis = new THREE.Vector3(0,1,0) //y-axis
// 				var angle = THREE.Math.degToRad(SCENEdata.OBJECTS[obj].rotationDegrees.y[frame])
// 				object.rotateOnWorldAxis(axis,angle)
// 				var axis = new THREE.Vector3(0,0,1) //z-axis
// 				var angle = THREE.Math.degToRad(SCENEdata.OBJECTS[obj].rotationDegrees.z[frame])
// 				object.rotateOnWorldAxis(axis,angle)
// 					scene[i].add(object)
// 			} else{
// 				scene[i].remove(object)
// 			}
// 		}
// 				renderer.render(scene[i],camera)
// 				console.timeEnd('frame render')
// 				scene[i].remove(light)
// 	  frame ++;
// 	if (frame <=numframe-1){
// 	setTimeout(animate,500)
// 	} else {
// 		frame = 0;
// 		setTimeout(animate,500)
// 	}
// 	}
// 	}
// }
//--------------------------------------------------------------------------------------------

	// 4. add light and object to the scene
	console.time('add object to scene')
    for (i=0; i<numScene;i++){
	await addToScene(scene[i],sceneType)
}
	console.timeEnd('add object to scene')

	//5. preload(compile) shaders
	console.time('compile')
     for (i=0; i<numScene;i++){
  renderer.compile(scene[i],camera)
}
	console.timeEnd('compile')

	//6. Animate
	frame = 0
	animate()

    function animate(){

// imgData = renderer.domElement.toDataURL();
//      getImageData = false;

    if (frame <=numframe-1){
    setTimeout(animate,500)
    } else {
        frame = 0;
        setTimeout(animate,500)
    }
    render()
    frame ++;
    }

function render(){
    // update current frame Light and Obj Properties
	//controls.update()
    console.log(frame)
    for (i=0;i<numScene;i++){
    	console.time('frame update')
        updateSingleFrame(scene[i])
        console.timeEnd('frame update')
    }
 for (i=0;i<numScene;i++){

     console.time('frame render')
    renderer.render(scene[i],camera)
    console.timeEnd('frame render')
}
//   // update the picking ray with the camera and mouse position
//   raycaster.setFromCamera( mouse, camera );

// // calculate objects intersecting the picking ray
// var intersects = raycaster.intersectObjects( scene[i].children );

// for ( var i = 0; i < intersects.length; i++ ) {
// 	intersects[ i ].object.material.color.set( 0xff0000 );
// }
}


	//============= AWAIT LOAD PARAMS =============//
	if (FLAGS.need2loadParameters == 1){
		var old_ImageBagsSample = TASK.ImageBagsSample
		var old_ImageBagsTest = TASK.ImageBagsTest

		var old_ObjectGridIndex = TASK.ObjectGridIndex
		var old_NTrialsPerBagBlock = [TASK.NTrialsPerBagBlock]
		FLAGS.need2loadParameters = await loadParametersfromFirebase(ENV.ParamFileName);

		//============= SET UP CANVAS =============//
		// Update canvas based on latest TASK state:
		refreshCanvasSettings(TASK);
		setupCanvasHeadsUp()
		setupImageLoadingText()
		windowWidth = document.body.clientWidth; //get true window dimensions at last possible moment
		windowHeight = document.body.clientHeight;
		setupCanvas(VISIBLECANVAS);
		if (ENV.DevicePixelRatio !== 1){
			scaleCanvasforHiDPI(VISIBLECANVAS);
		}
		if (ENV.OffscreenCanvasAvailable){
			OFFSCREENCANVAS = new OffscreenCanvas(VISIBLECANVAS.width, VISIBLECANVAS.height)
			OFFSCREENCANVAS.commitTo = function(dest){
				try {
					var bitmap = this.transferToImageBitmap()
					dest.transferFromImageBitmap(bitmap)
					str = {status: "succeeded"}
					return str
				}
				catch(error){
					console.log(error)
					str = {status: "failed"}
					return str
				}
			}
		}
		else
		{
			OFFSCREENCANVAS = VISIBLECANVAS
		}

		CANVAS.workspace = [
			0,
			0,
			VISIBLECANVAS.width,
			VISIBLECANVAS.height
		]

		// Check if images were changed
		if(!old_ImageBagsTest.equals(TASK.ImageBagsTest) ||
			!old_ImageBagsSample.equals(TASK.ImageBagsSample) ||
			!old_ObjectGridIndex.equals(TASK.ObjectGridIndex) ||
			!old_NTrialsPerBagBlock.equals([TASK.NTrialsPerBagBlock]))
		{
			FLAGS.need2loadImagesTrialQueue = 1;
		}
		FLAGS.purge = 1
		FLAGS.createnewfirestore = 1
		EVENTS.reset()
	} //if need2loadParameters

	if (FLAGS.purge == 1){
		purgeTrackingVariables()
		FLAGS.purge = 0;
	} //if purge


	//============ CREATE IMAGE BAG & DISPLAY GRID ============//
	if (FLAGS.need2loadImagesTrialQueue == 1){
		if(TASK.Automator != 1){
			// Make TrialQueue
			var samplingStrategy = 'uniform_with_replacement' // todo: add more options; move into TASK
			TQ = new TrialQueue(samplingStrategy, TASK.ImageBagsSample, TASK.ImageBagsTest)
			await TQ.build(num_prebuffer_trials)
		}
		else if(TASK.Automator == 1){
			TQ = AutomatorPreBuffer.TrialQueue[TASK.AutomatorStage]
		} //if automator
		samplebag_paths = TQ.samplebag_paths
		samplebag_labels = TQ.samplebag_labels
		testbag_paths = TQ.testbag_paths
		testbag_labels = TQ.testbag_labels

		var funcreturn = objectomeImageNamesToLatentVars(samplebag_paths,samplebag_labels)
		IMAGES.Sample = funcreturn[0]
		IMAGES.object.sample = funcreturn[1]

		IMAGES.Sample["Reward"] = []
		for (var i=0; i<=samplebag_paths.length-1; i++){
			if (typeof(ImageRewardList[ samplebag_paths[i] ]) != "undefined"){
				IMAGES.Sample["Reward"][i] = ImageRewardList[ samplebag_paths[i] ]
			}
			else {
				IMAGES.Sample["Reward"][i]= -1
			}
		}

		var funcreturn = objectomeImageNamesToLatentVars(testbag_paths,testbag_labels)
		IMAGES.Test = funcreturn[0]
		IMAGES.object.test = funcreturn[1]

		var keys = Object.keys(IMAGES.Sample)
		for (var i=0; i<=keys.length-1; i++){
			IMAGES.Sample["Sample" + keys[i]] = IMAGES.Sample[keys[i]]
			delete IMAGES.Sample[keys[i]]
		} //for i keys

		var keys = Object.keys(IMAGES.Test)
		for (var i=0; i<=keys.length-1; i++){
			IMAGES.Test["Test" + keys[i]] = IMAGES.Test[keys[i]]
			delete IMAGES.Test[keys[i]]
		} //for i keys

		// Write down dimensions of (assumedly) all images in samplebag and testbag, based on the first sample image.
		await TQ.generate_trials(1)
		var representative_image = await TQ.IB.get_by_name(TQ.sampleq.filename[0])
		// var representative_image = await imagebag.get_by_name(samplebag_paths[0])
		ENV.ImageWidthPixels = representative_image.width
		ENV.ImageHeightPixels = representative_image.height

		IMAGES.imagepaths.Ordered_Samplebag_Filenames = samplebag_paths
		IMAGES.imagepaths.Ordered_Testbag_Filenames = testbag_paths
		IMAGES.imagepaths.Ordered_SampleImageRewardList = IMAGES.Sample.SampleReward

		FLAGS.need2loadImagesTrialQueue = 0;
	} //if need2loadImagesTrialQueue

	ENV.InchScale = ENV.ViewportPPI/(ENV.ImageWidthPixels*ENV.CanvasRatio)

	ENV.FixationScale = ENV.InchScale*TASK.FixationSizeInches
	ENV.SampleScale = ENV.InchScale*TASK.SampleSizeInches
	ENV.TestScale = ENV.InchScale*TASK.TestSizeInches
	ENV.ChoiceScale = ENV.InchScale*TASK.ChoiceSizeInches

	ENV.FixationRadius = TASK.FixationSizeInches/2 * ENV.ViewportPPI
	ENV.ChoiceRadius = TASK.ChoiceSizeInches/2 * ENV.ViewportPPI

// 	ENV.FixationRadius=(ENV.ImageWidthPixels/2)*TASK.FixationScale*ENV.CanvasRatio
// 	ENV.ChoiceRadius=(ENV.ImageWidthPixels/2)*TASK.ChoiceScale*ENV.CanvasRatio
	// define image display grid
	funcreturn = defineImageGrid(TASK.NGridPoints, TASK.GridSpacingInches*ENV.ViewportPPI);

	xcanvascenter = funcreturn[0]
	ycanvascenter = funcreturn[1]
	ENV.XGridCenter = funcreturn[2]
	ENV.YGridCenter = funcreturn[3]
	//============ (end) CREATE IMAGE BAG & DISPLAY GRID ============//

	//============ SELECT SAMPLE & TEST IMAGES ============//
	// Draw one (1) sample image from samplebag
	// console.time('trial images loadtime:')
	var c
	[CURRTRIAL.sampleimage, CURRTRIAL.sampleindex, CURRTRIAL.testimages, CURRTRIAL.testindices, CURRTRIAL.correctitem, samplereward] = await TQ.get_next_trial();
	// console.timeEnd('trial images loadtime:')

	logEVENTS("Sample",CURRTRIAL.sampleindex,"trialseries")
	logEVENTS("Test",CURRTRIAL.testindices,"trialseries")
	logEVENTS("CorrectItem",CURRTRIAL.correctitem,"trialseries")

	var keys = Object.keys(IMAGES.object.sample)
	for (var i=0; i<=keys.length-1; i++){
		CURRTRIAL["sampleobject" + keys[i]] = IMAGES.object.sample[keys[i]][CURRTRIAL.sampleindex]
	}

	var keys = Object.keys(IMAGES.object.test)
	if (TASK.TestON <= 0){
		for (var i=0; i<=keys.length-1; i++){
			for (var j=0; j<=CURRTRIAL.testindices.length-1; j++){
				CURRTRIAL["testobject" + keys[i]][j] = IMAGES.object.test[keys[i]][CURRTRIAL.testindices[j]]
			}
		}
	} //IF SR2 or M2S
	else if (TASK.TestON > 0){
		for (var i=0; i<=keys.length-1; i++){
			CURRTRIAL["testobject" + keys[i]] = IMAGES.object.test[keys[i]][0]
		}
	} //IF same-different

	logEVENTS("SampleObjectTy",CURRTRIAL.sampleobjectty,"imageseries")
	logEVENTS("SampleObjectTz",CURRTRIAL.sampleobjecttz,"imageseries")
	logEVENTS("SampleObjectRxy",CURRTRIAL.sampleobjectrxy,"imageseries")
	logEVENTS("SampleObjectRxz",CURRTRIAL.sampleobjectrxz,"imageseries")
	logEVENTS("SampleObjectRyz",CURRTRIAL.sampleobjectryz,"imageseries")
	logEVENTS("SampleObjectScale",CURRTRIAL.sampleobjectscale,"imageseries")

	logEVENTS("TestObjectTy",CURRTRIAL.testobjectty,"imageseries")
	logEVENTS("TestObjectTz",CURRTRIAL.testobjecttz,"imageseries")
	logEVENTS("TestObjectRxy",CURRTRIAL.testobjectrxy,"imageseries")
	logEVENTS("TestObjectRxz",CURRTRIAL.testobjectrxz,"imageseries")
	logEVENTS("TestObjectRyz",CURRTRIAL.testobjectryz,"imageseries")
	logEVENTS("TestObjectScale",CURRTRIAL.testobjectscale,"imageseries")


	//================= RFID check =================//
	// If no matching read in the last TASK.CheckRFID seconds, wait for matching read
	// (kicks-them-off model where they can work as long as reading, but then get kicked off within TASK.CheckRFID seconds if they are the wrong agent or no reads)
	if (TASK.CheckRFID > 0 && ENV.AgentRFID != "XX" && FLAGS.savedata == 1){
		if (port.connected == false){
			console.log('NO USB DEVICE CONNECTED: cannot check RFID!!')
		}
		else if (port.connected == true){
			var nreads = TRIAL.RFIDTag.length
	    	if (TRIAL.RFIDTag[nreads-1] == ENV.AgentRFID && (Date.now() - ENV.CurrentDate.valueOf()) - TRIAL.RFIDTime[nreads-1] < TASK.CheckRFID){
	    		// RFID checks out
	    	}
	    	else{ //wait for a recent rfid read before proceeding with next trial
				await rfid_promise(ENV.AgentRFID,TASK.CheckRFID)
	    	}
		}
	}
	//================= (end) RFID check =================//

	//============ WHILE RUN FIXATION SCREEN ============//
	FLAGS.waitingforTouches = TASK.NFixations
	if (TASK.RewardStage == 0){
		FLAGS.punishOutsideTouch = 1
	}
	CURRTRIAL.allfixationxyt = []
	while (FLAGS.waitingforTouches > 0){
		// Choose fixation grid index at random
		if (TASK.FixationMove > 0){
			CURRTRIAL.fixationgridindex = Math.floor((ENV.XGridCenter.length)*Math.random());
		}
		else if (TASK.FixationMove <= 0){
			CURRTRIAL.fixationgridindex = TASK.StaticFixationGridIndex;
		}
		logEVENTS("FixationGridIndex",CURRTRIAL.fixationgridindex,"trialseries")

		// Render fixation screen
		if(TASK.FixationUsesSample != 1){
			if (TASK.Species == "macaque" || TASK.Species == "human"){
				ENV.FixationColor = "white";
			}
			else if (TASK.Species == "marmoset"){
				ENV.FixationColor = "blue";
			}
		}

		// Start timer for this fixation render trial.
		CURRTRIAL.starttime=Date.now() - ENV.CurrentDate.valueOf();
		logEVENTS("StartTime",CURRTRIAL.starttime,"trialseries")

		frame.shown=[];
		for (var q in CANVAS.sequencepre){
			frame.shown[q]=0
		};
		frame.current=0;

		//========= AWAIT SHOW FIXATION =========//
		// todo: move to appropriate location
		if (TASK.Species == 'marmoset'){
			playSound(0)
		}
		renderScreen(CANVAS.sequencepre[0],OFFSCREENCANVAS)
		await displayTrial(CANVAS.sequencepre,CANVAS.tsequencepre);
		audiocontext.suspend()

		//========= AWAIT HOLD FIXATION TOUCH =========//
		if (FLAGS.stressTest == 1){
			var touchhold_return = {type: "theld"}

			var x = boundingBoxesFixation.x[0][0] + Math.round(Math.random()*(boundingBoxesFixation.x[0][1] - boundingBoxesFixation.x[0][0]))

			var y = boundingBoxesFixation.y[0][0] + Math.round(Math.random()*(boundingBoxesFixation.y[0][1] - boundingBoxesFixation.y[0][0]))

			touchhold_return.cxyt = [0,x,y,Date.now() - ENV.CurrentDate.valueOf()]

			FLAGS.waitingforTouches--
		}
		else {
			var touchhold_return = await touchhold_promise(TASK.FixationDuration,boundingBoxesFixation,FLAGS.punishOutsideTouch)
		}

		CURRTRIAL.fixationtouchevent = touchhold_return.type
		CURRTRIAL.fixationxyt = [touchhold_return.cxyt[1], touchhold_return.cxyt[2], touchhold_return.cxyt[3]]
		CURRTRIAL.allfixationxyt[TASK.NFixations - FLAGS.waitingforTouches - 1] = CURRTRIAL.fixationxyt

		logEVENTS("FixationTouchEvent",CURRTRIAL.fixationtouchevent,"trialseries")
		logEVENTS("FixationXYT",CURRTRIAL.fixationxyt,"trialseries")

		if (CURRTRIAL.fixationtouchevent == "theld"){
			if (TASK.RewardStage == 0 && FLAGS.waitingforTouches == 0){
				CURRTRIAL.response = CURRTRIAL.correctitem
				logEVENTS("Response",CURRTRIAL.response,"trialseries")
			}
		} //touched fixation
		else if (CURRTRIAL.fixationtouchevent == "tbroken" &&
			TASK.RewardStage == 0){
			CURRTRIAL.response = -1
			FLAGS.waitingforTouches = 0 //exit loop
			logEVENTS("Response",CURRTRIAL.response,"trialseries")
		} //fixation task, but touched outside fixation
		else if (CURRTRIAL.fixationtouchevent == "tbroken" &&
			TASK.RewardStage == 1){
			//dms task, ok if touched outside, just wait for touch inside fixation area
		}


		//========= AWAIT CLEAR FIXATION =========//
		for (var q in CANVAS.sequenceblank){frame.shown[q]=0}
		frame.current=0;
		if (FLAGS.waitingforTouches > 0){
			renderScreen(CANVAS.sequenceblank[0],OFFSCREENCANVAS)
			await displayTrial(CANVAS.sequenceblank,CANVAS.tsequenceblank);
		} //blank out screen
	} //while waiting for NFixations
	//============ (end) WHILE RUN FIXATION SCREEN ============//

	//============== AWAIT SHOW SAMPLE THEN TEST ==============//
	if (TASK.RewardStage === 1){
		frame.shown=[]
		for (var q in CANVAS.sequence){frame.shown[q]=0}
		frame.current=0
		renderScreen(CANVAS.sequence[0],OFFSCREENCANVAS)
		CURRTRIAL.tsequenceactual = await displayTrial(CANVAS.sequence,CANVAS.tsequence);
		CURRTRIAL.tsequencedesired = CANVAS.tsequence
		audiocontext.suspend()

		logEVENTS("TSequenceActual",CURRTRIAL.tsequenceactual,"trialseries")
		logEVENTS("TSequenceDesired",CURRTRIAL.tsequencedesired,"trialseries")


		//========= AWAIT TOUCH RESPONSE =========//
		FLAGS.waitingforTouches = 1
		if (TASK.HideTestDistractors >= 1){
			FLAGS.punishOutsideTouch = 1
		}
		else {
			FLAGS.punishOutsideTouch = 0
		}
		if (FLAGS.stressTest == 1){
			var race_return = {type: "theld"}

			var nchoices = boundingBoxesChoice.x.length
			// var currchoice = CURRTRIAL.correctitem
			var hitrate = 0
			if (ENV.Subject == "Youno"){
				hitrate = 0.9
			}
			else if (ENV.Subject == "Eliaso"){
				hitrate = 0.7
			}
			if (Math.random() < hitrate){
				var currchoice = CURRTRIAL.correctitem
			}
			else {
				var distractor_array = []
				for (var i=0; i<=nchoices-1; i++){
					if (i != CURRTRIAL.correctitem){
						distractor_array.push(i)
					}
				}
				distractor_array = shuffle(distractor_array)
				var currchoice = distractor_array[0]
			}

			var x = boundingBoxesChoice.x[currchoice][0] + Math.round(Math.random()*(boundingBoxesChoice.x[currchoice][1] - boundingBoxesChoice.x[currchoice][0]))

			var y = boundingBoxesChoice.y[currchoice][0] + Math.round(Math.random()*(boundingBoxesChoice.y[currchoice][1] - boundingBoxesChoice.y[currchoice][0]))

			race_return.cxyt = [currchoice,x,y,Date.now() - ENV.CurrentDate.valueOf()]

			FLAGS.waitingforTouches--
		}
		else {
			var p1 = touchhold_promise(0,boundingBoxesChoice,FLAGS.punishOutsideTouch)
			var p2 = choiceTimeOut(TASK.ChoiceTimeOut)

			var race_return = await Promise.race([p1,p2])
		}

		CURRTRIAL.responsetouchevent = race_return.type
		CURRTRIAL.response = race_return.cxyt[0]
		CURRTRIAL.responsexyt = [race_return.cxyt[1], race_return.cxyt[2], race_return.cxyt[3]]

		logEVENTS("ResponseXYT",CURRTRIAL.responsexyt,"trialseries")
		logEVENTS("ResponseTouchEvent",CURRTRIAL.responsetouchevent,"trialseries")
		logEVENTS("Response",CURRTRIAL.response,"trialseries")

		// Keep track of repeated responses to one side
		if (CURRTRIAL.num > 0 && FLAGS.savedata && CURRTRIAL.responsetouchevent == "theld"){
			if (CURRTRIAL.response==trialhistory.response[trialhistory.correct.length-1]){
				FLAGS.stickyresponse++;
			}
			else {
				FLAGS.stickyresponse=0;
			}
		} //if
	} //if TASK.RewardStage

	// Determine if Choice was correct
	if (CURRTRIAL.response == CURRTRIAL.correctitem){ CURRTRIAL.correct = 1; }
	else { CURRTRIAL.correct=0; }


	// console.log('response:', CURRTRIAL.response)
	// console.log('correct response', CURRTRIAL.correctitem)

	//============ DETERMINE NUMBER OF REWARDS ============//
	if (samplereward == 0){
		CURRTRIAL.nreward = -1 //skip reward/punish
	}
	else if (CURRTRIAL.correct && samplereward == -1){ //default behavior
		if (FLAGS.savedata && (CURRTRIAL.starttime - trialhistory.starttime[trialhistory.starttime.length-1] < TASK.ConsecutiveHitsITI || CURRTRIAL.num==0)){
			// if correct within bonus interval
			FLAGS.consecutivehits++
		}
		else {
			// took too long, set to 1
			FLAGS.consecutivehits=1
		}
		CURRTRIAL.nreward = 1 + Math.floor(FLAGS.consecutivehits / TASK.NConsecutiveHitsforBonus)

		if (CURRTRIAL.nreward > TASK.NRewardMax){
			CURRTRIAL.nreward = TASK.NRewardMax
		}
	}
	else if (CURRTRIAL.correct && samplereward >= 1){
		//Override if user had manually set reward for that sample image in image_reward_list file
		CURRTRIAL.nreward = samplereward
	}
	else if (!CURRTRIAL.correct){
			FLAGS.consecutivehits=0;
			CURRTRIAL.nreward = 0;
	} //# of rewards to give

	ENV.RewardDuration = setReward();
	logEVENTS("NReward",CURRTRIAL.nreward,"trialseries")

	//============ DELIVER REWARD/PUNISH ============//
	//NO FEEDBACK
	if (  CURRTRIAL.nreward == -1 ){
		CANVAS.sequencepost[1] = "blank";
		CANVAS.tsequencepost[2] = 2*CANVAS.tsequencepost[1];
		frame.shown=[];
		for (var q in CANVAS.sequencepost){frame.shown[q]=0}; frame.current=0;

		renderScreen(CANVAS.sequencepost[0],OFFSCREENCANVAS)
		await displayTrial(CANVAS.sequencepost,CANVAS.tsequencepost);
	}
	// REWARD
	else if (CURRTRIAL.correct){
		CANVAS.sequencepost[1]="reward";
		CANVAS.tsequencepost[2] = CANVAS.tsequencepost[1]+ENV.RewardDuration*1000;

		for (var q = 0; q <= CURRTRIAL.nreward-1; q++){
			frame.shown=[];
			for (var q2 in CANVAS.sequencepost){frame.shown[q2]=0}; frame.current=0;

			playSound(2);
			renderScreen(CANVAS.sequencepost[0],OFFSCREENCANVAS)
			var p1 = displayTrial(CANVAS.sequencepost,CANVAS.tsequencepost)
			if (ble.connected == false && port.connected == false){
				await Promise.all([p1])
			}
			else if (ble.connected == true){
				var p2 = writepumpdurationtoBLE(Math.round(ENV.RewardDuration*1000))
				await Promise.all([p1, p2])
			}
			else if (port.connected == true){
				var p2 = port.writepumpdurationtoUSB(Math.round(ENV.RewardDuration*1000))
				await Promise.all([p1, p2])
			}

		} //for nrewards
	}
	//PUNISH
	else if (!CURRTRIAL.correct) {
		CANVAS.sequencepost[1] = "punish";
		CANVAS.tsequencepost[2] = CANVAS.tsequencepost[1]+TASK.PunishTimeOut;
		frame.shown=[];
		for (var q in CANVAS.sequencepost){frame.shown[q]=0}; frame.current=0;

		renderScreen(CANVAS.sequencepost[0],OFFSCREENCANVAS)
		var p1 = displayTrial(CANVAS.sequencepost,CANVAS.tsequencepost);
		var num_trials_to_buffer_in_punishperiod = 50
		var p2 = TQ.generate_trials(num_trials_to_buffer_in_punishperiod)
		playSound(3);
		// console.time('punish download/timeout')
		await Promise.all([p1,p2])
		// console.timeEnd('punish download/timeout')
	}
	//============ (end) DELIVER REWARD/PUNISH ============//

	//================= HOUSEKEEPING =================//
	CURRTRIAL.lastTrialCompleted = new Date()
	// Update TRIAL only if saving data
	if (FLAGS.savedata == 1){
		// Update trial tracking variables
		updateTRIAL() //appends current trial info
		updateTrialHistory() //appends to running trial history

		// Run automator
		if (TASK.Automator !=0){
			await automateTask(automator_data, trialhistory);
		}

		// Save data asynchronously
		saveBehaviorDatatoFirebase(TASK, ENV, CANVAS, TRIAL);

		// Save data asynchronously to Firestore
		if (FLAGS.createnewfirestore == 1){
			saveBehaviorDatatoFirestore(TASK,ENV,CANVAS); //write once
			pingFirestore() //every 10 seconds, will check for data updates to upload to firestore
		} //kick off firestore database writes
	} //if savedata

	if (FLAGS.need2saveParameters == 1){
		// FLAGS.need2saveParameters = saveParameterstoDropbox(); // Save parameters asynchronously
		FLAGS.need2saveParameters = saveParameterstoFirebase(); // Save parameters asynchronously
	}

	//FLAGS.need2loadParameters=1: reload task which automatically creates a new data file
// 	checkParameterFileStatus()
	await checkParameterFileStatusFirebase()
	if ( (new Date).getDate() != ENV.CurrentDate.getDate() ||
			CURRTRIAL.num == 1000){ //in local time
		updateEventDataonFirestore(EVENTS);
		FLAGS.need2loadParameters = 1
	} //if new day, start new file or reached 1000 trials
	//================= (end) HOUSEKEEPING =================//

	updateHeadsUpDisplay();
	console.log('End of trial ', CURRTRIAL.num)
	CURRTRIAL.num++
	EVENTS.trialnum = CURRTRIAL.num
}
})();

</script>
</body>

</html>
